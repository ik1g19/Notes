{"path":"Drive Sync/Lecture Slides/Programming I/Environments.pdf","text":"Comp1004: Environments The Java Library Coming up • Recap – Encapsulation – Constructors – Loops – Arrays – ArrayList – Iterators • The Java Library – Implementation vs. interface – Example 1: Strings – Example 2: Hashmap Recap Encapsulation Take this example class where age is modelled as an int public class Student { int age = 20; //code omitted public static void main(String[] args){ Student s1 = new Student(); System.out.println(s1.getAge()); } public int getAge(){ return age; } } Encapsulation public class Student { //int age = 20; Calendar dateOfBirth; //code omitted public static void main(String[] args){ Student s1 = new Student(); System.out.println(s1.getAge()); } //public int getAge(){ // return age; //} public int getAge(){ Calendar rightNow = Calendar.getInstance(); int a = calculateAge(rightNow, dateofBirth); return a; } } Take this example class where age is modelled as an int We might change the way that age is implemented – e.g. to make it based on the current date. Because we used an Accessor we do not need to alter main Encapsulation public class Student { //int age = 20; protected Calendar dateOfBirth; //code omitted public static void main(String[] args){ Student s1 = new Student(); System.out.println(s1.getAge()); } //public int getAge(){ // return age; //} public int getAge(){ Calendar rightNow = Calendar.getInstance(); int a = calculateAge(rightNow, dateofBirth); return a; } } The protected keyword tells Java that only methods in this class* can access this variable. *and its sub-classes, but we’ll come to that later in the course… And yes, public means the opposite – that all other methods can access it! Constructors public class Student { protected age; public Student() { age = 20; } public Student(int a) { age = a; } public static void main(String[] args){ Student s1 = new Student(19); System.out.println(s1.getAge()); } //code omitted } Constructor Rules: • Must have the same name as the class • Does not need a return type • Can take parameters • Can be overloaded • Are invoked at the point of creation using the new keyword Loops int i = 0; while(i < 10){ System.out.println(i); i++; } int i = 0; do { System.out.println(i); i++; } while (i < 10); for (int i = 0; i < 10; i++) { System.out.println(i); } initialization; condition; statechange Loops for (int i = 0; i < 10; i++) { System.out.println(i); } int i = 0; while(i < 10){ System.out.println(i); i++; } initialization; condition; statechange Condition is checked at start. Loops zero or more times. int i = 0; do { System.out.println(i); i++; } while (i < 10); Condition is checked at end. Loops one or more times. A convenience loop for when we know it advance how many times we want to iterate. Loops zero or more times. Arrays int[] numStore; numStore = new int[9]; numStore[0] = 77; System.out.println(numStore[0]); [ ] 10 2 3 4 5 6 7 8 77 numStore int[] Declaration Instantiation Assignment Retrieval Iterating Over an Array int numStore = new int[9]; //some missing code to fill the array with values for(int i = 0; i < 9; i++){ System.out.print(“Number at position ” + i); System.out.println(“ is ” + numStore[i]); } Iterating over an array is so common that Java now includes a loop specifically to do it. int numStore = new int[9]; //some missing code to fill the array with values for(int n : numStore){ System.out.println(“Number is ” + n); } Like the for loop the ‘for each’ loop is a shortcut, that is a bit neater than writing the code the long way. But it can only be used for access (e.g. n++ would not increment the value in the array) And it hides the current index Array vs ArrayList Array ArrayList Cat[] catArray; catArray = new Cat[10]; catArray[0] = moggy1; catArray[1] = moggy2; callMethodOn(catArray[1]); catArray[0] = null; ArrayList catAList; catAList = new ArrayList(); catAList.add(moggy1); catAList.add(moggy2); callMethodOn(catAList.get(1)); catAList.remove(moggy1); Insertion Access RemovalDeclaration Generics ArrayList kennel = new ArrayList(); kennel.add(new Dog(“Rover”)); kennel.add(new Dog(“Fido”)); kennel.add(new Dog(“Patch”)); kennel.add(new Cat(“Mr Tiddles”)); for(int i = 0; i < kennel.size(); i++) { kennel.get(i).bark(); } ArrayLists store objects of any type Which means we can mix up the types of objects in the ArrayList Which may cause problems later if we make assumptions about what is in there! In fact this code will not compile, because Java does not know what is in the ArrayList, and therefore will not let you call bark on it Generics ArrayList<Dog> kennel = new ArrayList<Dog>(); kennel.add(new Dog(“Rover”)); kennel.add(new Dog(“Fido”)); kennel.add(new Dog(“Patch”)); kennel.add(new Cat(“Mr Tiddles”)); for(int i = 0; i < kennel.size(); i++) { kennel.get(i).bark(); } It would be better if we could ensure that the ArrayList only contained Dogs in the first place This is easily done because ArrayList uses a mechanism called generics. We can specify the type allowed when we create the ArrayList. Now Java will only allow us to add things of type Dog. So this line will force a compile time error Iterators ArrayList<Dog> kennel = new ArrayList<Dog>(); kennel.add(new Dog(“Rover”)); kennel.add(new Dog(“Fido”)); kennel.add(new Dog(“Patch”)); for(int i = 0; i < kennel.size(); i++) { kennel.get(i).bark(); } Iterator<Dog> it = kennel.iterator(); while(it.hasNext()) { it.next().bark(); } 1) They are neater, and neat code is easier to read and understand 2) They decouple the loop from the collection (notice that in the loop we do not reference the Arraylist at all) This means we could pass the iterator to a method – and that method does not even need to know what the collection is! Iterators public void makeThemBark(Iterator<Dog> it) { while(it.hasNext()) { it.next().bark(); } } 1) They are neater, and neat code is easier to read and understand 2) They decouple the loop from the collection (notice that in the loop we do not reference the Arraylist at all) This means we could pass the iterator to a method – and that method does not even need to know what the collection is! The Java Library Library • The java library is full of helpful classes • Like ArrayList • What does the inside of an ArrayList look like? • How does it handle the resizing? • How does it know when the throw an error? • How does it handle renumbering when removing elements? Implementation vs. Interface • Because of encapsulation all we need to know to use the ArrayList class, and the other library classes is what their interface is • A Class’ interface is how we interact with the class – It’s public variables and methods – what methods we can call – what they do – what they will return Importing • Library classes must be imported using an import statement import java.util.ArrayList; public class myClass{ ArrayList<String> arrl; arrl = new ArrayList<String>; public static void main(String[] args){ //code omitted } } Importing packages • Classes are organised in packages. • Single classes may be imported: import java.util.ArrayList; • Whole packages can be imported: import java.util.*; Where is the Library? • All library classes are included in the Java runtime and development environments • All the documentation is available online: – http://download.oracle.com/javase/6/docs/api/ Example 1: Strings Strings • Strings are actually objects – Did you notice we always use a capital S like other classes? • You don’t need to import them – they are from the automatically imported from java.lang.*; • As is System as in System.out.println() A word about comparing Strings if(input == “hello\") { //code here } if(input.equals(“hello\")) { //code here } • You probably mean to compare strings using .equals identity vs equality name1 String Harry Ron name2 String Tom • name1 == name2 • False, different addresses • name1.equals(name2) • False, different value • String name1 = “Harry”; • String name2 = “Tom”; identity vs equality name1 String Harry Ron name2 String Harry • String name1 = “Harry”; • String name2 = “Harry”; • name1 == name2 • False, different addresses • name1.equals(name2) • True, same value identity vs equality name1 String Harry name2 String • String name1 = “Harry”; • String name2 = name1; • name1==name2 • True, same address • name1.equals(name2) • True, same value Example 2: Hashmaps Maps • Maps are a collection type that map a key to a value • put(“Alfie”,“407351”); • and so on Memory Map: Name -> Phone number 4073 51 Alfie 7634 12 Jenny Lookup • Lookup is the act of supplying the key and having the value returned String num = myHashMap.get(“Alfie”); Memory myHashMap<String, Integer> 4073 51 Alfie Bringing it together… import java.util.HashMap; //code omitted HashMap<String, Integer> marks; marks = new HashMap<String, Integer>(); marks.put(\"Alice\", 75); marks.put(\"Bob\", 62); marks.put(\"Colin\", 68); System.out.println(\"Bob got \" + marks.get(\"Bob\")); Bringing it together… import java.util.HashMap; //code omitted HashMap<String, Integer> marks; marks = new HashMap<String, Integer>(); marks.put(\"Alice\", 75); marks.put(\"Bob\", 62); marks.put(\"Colin\", 68); System.out.println(\"Bob got \" + marks.get(\"Bob\")); What is this? Bringing it together… import java.util.HashMap; //code omitted HashMap<String, Integer> marks; marks = new HashMap<String, Integer>(); marks.put(\"Alice\", 75); marks.put(\"Bob\", 62); marks.put(\"Colin\", 68); System.out.println(\"Bob got \" + marks.get(\"Bob\")); What is this? HashMap is a generic class, this means we should tell it what two types it maps together Bringing it together… import java.util.HashMap; //code omitted HashMap<String, Integer> marks; marks = new HashMap<String, Integer>(); marks.put(\"Alice\", 75); marks.put(\"Bob\", 62); marks.put(\"Colin\", 68); System.out.println(\"Bob got \" + marks.get(\"Bob\")); What is this? HashMap is a generic class, this means we should tell it what two types it maps together What is happening here? Bringing it together… import java.util.HashMap; //code omitted HashMap<String, Integer> marks; marks = new HashMap<String, Integer>(); marks.put(\"Alice\", 75); marks.put(\"Bob\", 62); marks.put(\"Colin\", 68); System.out.println(\"Bob got \" + marks.get(\"Bob\")); What is this? HashMap is a generic class, this means we should tell it what two types it maps together What is happening here? This is autoboxing – the ints are automatically turned into Integers for us Bringing it together… import java.util.HashMap; //code omitted HashMap<String, Integer> marks; marks = new HashMap<String, Integer>(); marks.put(\"Alice\", 75); marks.put(\"Bob\", 62); marks.put(\"Colin\", 68); System.out.println(\"Bob got \" + marks.get(\"Bob\")); What is this? HashMap is a generic class, this means we should tell it what two types it maps together What is happening here? This is autoboxing – the ints are automatically turned into Integers for us Which type of String comparison is being used? Bringing it together… import java.util.HashMap; //code omitted HashMap<String, Integer> marks; marks = new HashMap<String, Integer>(); marks.put(\"Alice\", 75); marks.put(\"Bob\", 62); marks.put(\"Colin\", 68); System.out.println(\"Bob got \" + marks.get(\"Bob\")); What is this? HashMap is a generic class, this means we should tell it what two types it maps together What is happening here? This is autoboxing – the ints are automatically turned into Integers for us Which type of String comparison is being used? Equality (not Identity). It is using the .equals method Summary • Recap – Encapsulation – Constructors – Loops – Arrays – ArrayList – Iterators • The Java Library – Class interface – Example 1: Strings – Example 2: Hashmap","libVersion":"0.3.2","langs":""}