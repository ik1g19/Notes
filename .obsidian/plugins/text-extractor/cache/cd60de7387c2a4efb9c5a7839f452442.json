{"path":"Drive Sync/Matthew Barnes Notes/Programming III Notes.pdf","text":"Computer Science / Software Engineering Notes Network Programming III Matthew Barnes, Mathias Ritter In tro ductio n to fun ctio n al p ro grammin g 5 Features of Haskell 5 Bare basics 5 Standard prelude 6 Standard list functions 6 Function application 7 Useful GHCi Commands 7 Naming requirements 7 Layout rules 8 Typ es, C lasses an d Fun ctio n s 9 Types 9 Basic types 9 Compound types 10 List values 10 Curried functions 10 Polymorphism 11 Classes 12 Functions 14 Guarded equations 14 â€˜whereâ€™vs â€˜letâ€™and â€˜inâ€™ 16 Pattern matching 17 Lambda expressions 18 Operator sections 19 List C o mp rehen sio n an d Recursio n 19 List comprehension 19 Zips 20 Recursion 20 Tail recursion 21 Higher Order Fun ctio n s 23 Map, filter and fold 23 Dollar operator 23 Function composition 24 D eclarin g Typ es 24 Declaring Types and Classes 24 â€˜typeâ€™ 24 â€˜dataâ€™ 25 Computer Science / Software Engineering Notes Network â€˜newtypeâ€™ 26 â€˜classâ€™ 26 â€˜instanceâ€™ 26 Trees 27 Red-Black Trees 27 Abstract Syntax Trees 28 Functors 28 Directions, trails and zippers 30 Graphs 31 Indexed collections of Nodes, Edges 31 Structured data type with cyclic dependencies 31 Inductive approach with graph constructors 33 Evaluatio n Order an d Lazin ess 35 Equational reasoning 35 Redex 36 Beta-reduction 36 Call-By-Name 37 Call-By-Value 38 Modularity 38 Strict application 39 In terp reters an d C lo sures 40 Part 1 - Substitutions 40 Lambda calculus 40 Beta reduction syntax 41 Alpha conversion 41 Part 2 - Machines 42 Environments 42 Frames 43 Continuations 44 CEK-machines 44 Closures 45 Example sequence 47 Fun ctio n al I/O an d Mo n ads 50 I/O in Haskell 50 IO a 50 Actions 51 Do notation 51 Main Function, File Handling, Random Numbers 52 Applicatives 53 Monads 56 Use of monads:Error handling 58 Computer Science / Software Engineering Notes Network Use of monads:Chaining 59 Use of monads:Non-determinism 60 mapM 61 filterM 64 Fun ctio n al Pro grammin g in Java 67 Functions as Objects 67 Functional Interfaces 68 ActionListener 69 Lambda Syntax 70 More general function types 70 Closure:lambda vs anonymous inner classes (AICs) 72 Method references 74 Recursion 75 Pro grammin g with Streams 77 Functional programming and lists 77 External vs internal iteration 77 Streams in Java 77 Common operations 79 Map - Streams as Functors 79 flatMap - Streams as Monads 80 More stream operations yay 80 State of Streams 81 Optional 82 Parallel streams 82 Fun ctio n al Pro grammin g in JavaScrip t 84 Functional vs Imperative Style 84 Functional Features 85 Fun ctio n al Pro grammin g in JS with Rambda 85 Iterative Approach 86 Get a property 88 Filtering 88 Rejecting 90 New objects from old 90 Sorting 91 Functional Approach 91 TL;D R 93 Introduction to functional programming 93 Types, Classes and Functions 94 List Comprehension and Recursion 96 Higher Order Functions 96 Computer Science / Software Engineering Notes Network Declaring Types 97 Evaluation Order and Laziness 98 Interpreters and Closures 99 Functional I/O and Monads 99 Functional Programming in Java 101 Programming with Streams 102 Functional programming in JavaScript 103 Functional programming in JS with Rambda 103 Reco mmen ded Readin g 104 Computer Science / Software Engineering Notes Network Introduction to functional programming Features of Haskell - C o n cise Pro grams - few keywords, support for scoping by indentation - Po werful Typ e System - types are inferred by the compiler where possible - List C o mp rehen sio n s - construct lists by selecting and filtering - Recursive Fun ctio n s - efficiently implemented, tail recursive - Higher-Order Fun ctio n s - powerful abstraction mechanism to reuse code - Effectful Fun ctio n s - allows for side effects such as I/O - Gen eric Fun ctio n s - polymorphism for reuse of code - Lazy Evaluatio n - avoids unnecessary computation, infinite data structures - Eq uatio n al Reaso n in g - pure functions have strong correctness properties Bare basics - You can evaluate simp le exp ressio n s like this: - 5 + 6 (infix) - 3 - 1 (infix) - 8 `mod` 2 (infix) - (+) 5 6 (prefix) - (-) 3 1 (prefix) - mod 8 2 (prefix) - To create yo ur o wn fun ctio n s, do this: - [function name] [parameters] = [function body] - So, for example: - add x y = x + y - ... will add up two numbers. - To execute a fun ctio n , do this: - [function name] [function parameters] - Like this: - add 50 10 - This will add 50 and 10, given the definition of â€˜addâ€™above. - You donâ€™t need brackets or commas, like in Java or C;this is enough. Set theo ry Haskell a d d 5 : : I n t - > I n t a d d 5 x = x + 5 Computer Science / Software Engineering Notes Network Standard prelude - The Standard prelude is a library of common built-in functions. - It contains arithmetic functions, like +, -, div, mod etc. - It also has comparison functions, like >, <=, == etc. - A couple of examples include: - 3 * 7 - (*) 3 7 - mod 10 2 - 10 `mod` 2 - 1 - ( 2 * 3 ) - (1 - 2 ) * 3 - 5 >= (1 + 2) - 5 >= (-5) - Operations like +, -, * and / are all functions, and can be treated as such by wrapping them in brackets like (+), (-), (*) and (/). Standard list functions - There are a bunch of standard list functions that, when applied, can be really handy. Fun ctio n D escrip tio n Examp le head Selects the first element in the list head [ 1 , 2 , 3 , 4 ] -- will output '1' tail Removes the first element in a list tail [ 1 , 2 , 3 , 4 ] -- will output [2, 3, 4] length Calculates the length of a list length [ 1 , 2 , 3 , 4 ] -- will output 4 !! Selects the nth element of a list [ 1 , 2 , 3 , 4 ] !! 2 -- will output 3 take Selects the first n elements of a list take 2 [ 1 , 2 , 3 , 4 ] -- will output [1, 2] drop Removes the first n elements of a list drop 2 [ 1 , 2 , 3 , 4 ] -- will output [3, 4] ++ Appends two lists [ 1 , 2 ] ++ [ 3 , 4 ] -- will output [1, 2, 3, 4] sum Calculates the sum of the elements in a list sum [ 1 , 2 , 3 , 4 ] -- will output 10 product Calculates the product of the product [ 1 , 2 , 3 , 4 ] Computer Science / Software Engineering Notes Network elements in a list -- will output 24 reverse Reverses a list reverse [ 1 , 2 , 3 , 4 ] -- will output [4, 3, 2, 1] repeat Creates an infinite list of repeated elements repeat 5 -- will output [5, 5, 5, 5, ...] Function application - When running a function f with parameters a and b, you need to write it like this: - f a b - Because of this, you need to be careful about how Haskell interprets things: - f a + b = f(a) + b - f a + b â‰  f(a + b) - Haskell is left asso ciative, which means: - f a b c = ((f a) b) c Useful GHCi Commands C o mman d Mean in g :load name Load script name :reload Reload current script :set editor name Set editor to name :edit name Edit script name :edit Edit current script :type expr Show type of expression :? Show all commands :quit Quit GHCi Naming requirements - You should name your variables in lower camelCase: - myVariableName - var1 - helloWorld - You can also define new operators like this: (Â£) x y = x + y Computer Science / Software Engineering Notes Network 5 Â£ 6 -- output will be 11 - By convention, you should name your lists with a suffix â€˜sâ€™on the end: - xs, zs, lss Layout rules - In Haskell, whitespace matters, so you need your lines to be at the same column: -- do this a = 10 b = 20 c = 30 -- do not do this a = 10 b = 20 c = 30 - This also applies to the â€˜whereâ€™clause: Imp licit gro up in g Exp licit gro up in g a = b + c where b = 1 c = 2 d = a * 2 a = b + c where {b = 1 ; c = 2 } d = a * 2 Computer Science / Software Engineering Notes Network Types, Classes and Functions Types - A type is a name for a collection of related values. - Itâ€™s the same concept as types in Java or C. - To show that variable â€˜eâ€™has type â€˜tâ€™, you would write: e :: t - Though normally, you wouldnâ€™t have to do this because Haskell figures it out. This is called â€œtype inferenceâ€. - You can use the :type command to find the type of an expression: : type head ['j','g','c'] -- will output head ['j','g','c'] :: Char Basic types - Basic types are like primitives in Java or C. - Compound types are built up from basic types, and are combined using type operators. - The most common type operators are list types, function types and tuple types. B asic typ e D escrip tio n Typ e n ame Examp les Booleans Can be either true or false, it is 1 bit in size. Can be used with &&, || or â€˜notâ€™operators. Bool True ::Bool False ::Bool Characters Stores one character. Itâ€™s 2 words in size. Char â€˜jâ€™::Char â€˜#â€™::Char â€˜4â€™::Char Strings Stores a bunch of characters. Theyâ€™re not really a basic type, because theyâ€™re just lists of characters. String â€œThe Worldâ€::[ Char ] â€œMUDAâ€ ::[ Char ] â€œduwangâ€ ::[ Char ] â€œJoseph Joestarâ€ ::[ Char ] Numbers Int, Integer, Float, Double etc are all numbers The difference between â€œIntâ€ and â€œIntegerâ€ is that â€œIntâ€ is fixed in size and â€œIntegerâ€ is dynamic. Int Integer Float Double 7 ::Int 3.4 ::Float 9.56 ::Double 3587352 ::Int Computer Science / Software Engineering Notes Network Compound types C o mp o un d typ e D escrip tio n Typ e n ame Examp les Lists A collection of an element, of which all are the same type [ T ] (where T is the type of the elements) [ 6, 7, 3 ] ::[ Int ] [â€˜jâ€™, â€˜xâ€™] ::[ Char ] Tuples Tuples are fixed-size (immutable) lists. They can have any type at any position. ( T1, T2, T3 ... ) With Tn being the types of the tuple elements (4, 7.8, â€œoraâ€) ::(Int, Float, [Char]) Functions Functions take an input and spit an output out. The type of the input and output can be anything, even compound types. T -> U (With T being the input type and U being the output type) add ::(Int,Int) -> Int add (5,6) = 11 ora n = intercalate \" \" (take n (repeat \"ora\")) ora ::Int -> [Char] List values - The â€˜:â€™operator is called the â€˜consâ€™operator, and it appends an element to the beginning of a list. - For example: - 7 :[8, 9, 10] = [7, 8, 9, 10] - In fact, the cons operator forms the foundation of lists in Haskell. - All lists are just syntactic sugar for the cons operator being applied to an empty list. - Example: - [3, 4, 5] is just syntactic sugar for 3 :4 :5 :[] Curried functions - Function output types can be any type. But what if that type was another function? - Thatâ€™s whatâ€™s called a â€˜curriedâ€™function. A curried function only takes one argument, but it returns another function that carries out the rest. - Its type looks like this: add :: Int -> ( Int -> Int ) or Computer Science / Software Engineering Notes Network add :: Int -> Int -> Int - Which means you could do â€˜add 5â€™, then get the function, then use that function on â€˜6â€™ afterwards to get â€˜11â€™. - You may ask â€œHow do I curry functions in Haskell?â€ - The truth is, youâ€™ve been doing it all this time. Every function you see in Haskell is a curried function. There is no such thing as a function in Haskell that takes more than 1 parameter. - Donâ€™t believe me? Try :type (+) in GHCi (if you donâ€™t know, (+) is the function you use when you do something like 5 + 6). Youâ€™ll see it is of type Num a => a -> a -> a, which is the structure of a curried function. - You can also try :type (+) 5, and youâ€™ll see that the type of that is Num a => a -> a. By passing only one parameter to the + operator, you are getting a function from that curried function that adds anything itâ€™s given by 5. - When you run (+) 5 6, or 5 + 6, Haskell is actually getting a function from the curried function, and then using that returned function. This is possible in this syntax because Haskell is left asso ciative by default. - You can do currying with lots more parameters. Itâ€™ll look like this: mult :: Int â†’ ( Int â†’ ( Int â†’ Int )) mult x y z = x*y*z Polymorphism - What if we donâ€™t know what type we want? - For example, the â€˜lengthâ€™function can be applied with any list type, [Bool], [Int], [Char] etc. - Therefore, we can use a typ e variable to stand for â€œany typeâ€: - length ::[a] -> Int - The â€˜aâ€™in the above example is like a â€œplaceholderâ€ for any type. - A function is polymorphic if it uses one or more type variables. - Think of it like a generic in Java. - Lots of library functions in the standard prelude use type variables: fst :: (a,b) â†’ a head :: [a] â†’ a take :: Int â†’ [a] â†’ [a] zip :: [a] â†’ [b] â†’ [(a,b)] id :: a â†’ a - Remember, type variables must start with a lower-case letter. Computer Science / Software Engineering Notes Network Classes - What type is (+)? It canâ€™t use type variables, because you canâ€™t add Chars together. Itâ€™s sort of Int, Integer, Float and Double all at once. - (+) actually uses classes to solve this problem. - A class in Haskell isnâ€™t a class like in Java. In fact, itâ€™s more like an interface. - If a type inherits a class, it has specific properties that are common to all types that also inherit that class, just like a Java interface. - For example, if a function takes in an input that inherits class â€˜Numâ€™, then every input we put into that function must support the functionality that the class â€˜Numâ€™expects (e.g. we can pass in numbers, like â€˜5â€™, â€˜7.6â€™, â€˜3.4â€™because they support â€˜Numâ€™, but not values like â€œhelloâ€ or â€˜jâ€™because they do not support â€˜Numâ€™). - To show that a variable inherits a class, you write: N u m a - This shows that the variable â€˜aâ€™inherits the class â€˜Numâ€™. - Here is the full type of (+): ( + ) : : ( N u m a ) = > a - > a - > a - As you can see, the â€œNum aâ€ shows that the variable â€˜aâ€™refers to a number (it must be Int, Integer, Float or Double). - The arrow â€œ=>â€ just means that â€œthe left side of this is the type variable and class, the right side of this is the type itselfâ€, it doesnâ€™t have anything to do with functions. - You can inherit multiple classes, like this: showDouble :: ( Show a, Num a) => a -> String showDouble x = show (x + x) - The â€˜showDoubleâ€™method takes in a number, doubles it, then shows it using the â€˜showâ€™ function. - In order to be doubled, a variable must be a number, therefore it must inherit the â€˜Numâ€™ class. - In order to be shown, a variable must be able to convert to a string, therefore it must also inherit the â€˜Showâ€™class. - As you can see, â€œ(Show a, Num a)â€ shows that the type variable â€˜aâ€™must inherit both Show and Num classes. - The good thing about Haskell is that you usually donâ€™t have to declare inherited classes explicitly. Haskell will automatically see what classes a type variable needs and inherits them accordingly. Computer Science / Software Engineering Notes Network - You can try it yourself;create a quick function that adds numbers together, or shows variable values. Then, use :type to see the type of that function, and youâ€™ll see that the classes are already inherited. - Here are some more classes: C lass n ame D escrip tio n Examp le Eq Supports == and /= operations isEqual x y = x == y isEqual :: Eq a => a -> a -> Bool Ord Supports operators like < and > isBigger x y = x > y isBigger :: Ord a => a -> a -> Bool Show Supports being converted into a string toString x = show x toString :: Show a => a -> String Read Supports strings being converted into this fromString x = read x fromString :: Read a => String -> a Num Is either Int, Integer, Float or Double double x = x * 2 double :: Num a => a -> a Integral Is either Int or Integer (supports div and mod) divmod x y = (div x y + mod x y) divmod :: Integral a => a -> a -> a Fractional Is either Float or Double (supports / and recip, which means â€˜reciprocalâ€™) negrecip x = -1 * recip x negrecip :: Fractional a => a -> a - The classes are not all mutually exclusive. Ord supports < and >, but so does Real, because theyâ€™re numbers. Which do we pick:Ord or Real? - In reality, Real â€œextendsâ€ Ord, or is the â€˜childâ€™of Ord. Real has all the functionality of Ord, and then some. - Here is a hierarchy of the classes: Computer Science / Software Engineering Notes Network Functions Guarded equations - Haskell has if statements, but they can get very messy very quickly. You should never use them. - Instead, you can use guarded equations, which allow you to change the behaviour of a function based on a predicate (condition that returns true or false). - For example, letâ€™s take the factorial recursive algorithm. It can do two things:return 1 when the input is 0 (base case), or multiply the input by factorial(input - 1) (recursive clause). - In Haskell, you can do this in two ways: Pattern matchin g Guarded eq uatio n s fact 0 = 1 fact n = n * fact (n - 1 ) {- Keep in mind that this only works for a .hs file, it will not work on the GHCi interface unless you use :{ and :} -} fact n | n == 0 = 1 | n == 1 = 1 | otherwise = n * fact (n - 1 ) {- In theory, you should be able to leave out the n == 1 bit, but GHCi didn't like it when I tried that. -} - Letâ€™s take the guarded equation method and pick it apart to see how this works: Step s Value o f n Exp lan atio n Computer Science / Software Engineering Notes Network fact n | n == 0 = 1 | n == 1 = 1 | otherwise = n * fact (n - 1) 2 Here, we start by inputting the value of â€˜nâ€™into the factorial function. fact n | n == 0 = 1 | n == 1 = 1 | otherwise = n * fact (n - 1) 2 Now, we look at the first guarded equation predicate. If this is true, we do whatever is on the right of the equals sign next to it. If this is false, we move on to the next predicate. fact n | n == 0 = 1 | n == 1 = 1 | otherwise = n * fact (n - 1) 2 Itâ€™s false, so we look at the next predicate below it. The same rule applies here. fact n | n == 0 = 1 | n == 1 = 1 | otherwise = n * fact (n - 1) 2 Itâ€™s false, so we move on to the next predicate. The same rule applies here. â€˜otherwiseâ€™is like â€˜elseâ€™in Java or C, itâ€™s used when all other predicates are false. Itâ€™s syntactic sugar for â€œTrueâ€. fact n | n == 0 = 1 | n == 1 = 1 | otherwise = n * fact (n - 1) 2 â€˜otherwiseâ€™is always true, so we do whatâ€™s on the right of the equals sign here. This is the recursive clause, so we do the function again, but with n - 1. fact n | n == 0 = 1 | n == 1 = 1 | otherwise = n * fact (n - 1) 1 Here, we input the value of â€˜nâ€™into the factorial function again. fact n | n == 0 = 1 | n == 1 = 1 | otherwise = n * fact (n - 1) 1 We check the first predicate. If itâ€™s true, we do whatever is on the right. If not, move on to the next predicate. fact n | n == 0 = 1 | n == 1 = 1 | otherwise = n * fact (n - 1) 1 That was false, so we move on to the next predicate. fact n | n == 0 = 1 | n == 1 = 1 | otherwise = n * fact (n - 1) 1 That predicate was true, so we do whatâ€™s on the right of the equals sign next to it. It just says 1, so we return 1. - The order of the guards matter (just like if statements in Java), as the interpreter will go from top to bottom. - Using guarded equations, we can put error cases in our functions, like in this function that solves quadratic equations: Computer Science / Software Engineering Notes Network quadroots :: Float -> Float -> Float -> String quadroots a b c | a == 0 = error \"Not quadratic\" | b*b -4 *a*c == 0 = \"Root is \" ++ show (-b/ 2 *a) | otherwise = \"Upper Root is \" ++ show ((-b + sqrt(abs(b*b -4 *a*c)))/ 2 *a)) ++ \"and Lower Root is \" ++ show ((-b - sqrt(abs(b*b -4 *a*c)))/ 2 *a)) - This is a little ugly, though... isnâ€™t there some way we can locally define constants? â€˜whereâ€™vs â€˜letâ€™and â€˜inâ€™ - â€˜whereâ€™allows you to locally define constants within the scope of your functions. - Using the quadratic example above, we can do: quadroots :: Float -> Float -> Float -> String quadroots a b c | a== 0 = error \"Not quadratic\" | discriminant== 0 = \"Root is \" ++ show centre | otherwise = \"Upper Root is \" ++ show (centre + offset) ++ \" and Lower Root is \" ++ show (centre - offset) where discriminant = abs(b*b -4 *a*c) centre = -b/ 2 *a offset = sqrt(discriminant/ 2 *a) - Now, the local variables â€˜discriminantâ€™, â€˜centreâ€™and â€˜offsetâ€™are available within the scope of the function! - Doing this helps tidy up code and aid readability. - Make sure to indent the left of â€˜whereâ€™appropriately, or the Haskell interpreter will complain. - â€˜letâ€™an d â€˜in â€™allows you to also define local variables inside a scope. - Example: add x y = let z = x + y in z - In this example, we have a function â€˜addâ€™that takes in â€˜xâ€™and â€˜yâ€™. - In that function, we let â€˜zâ€™equal â€˜xâ€™+ â€˜yâ€™within the scope of the next line. - In that next line, weâ€™re not really doing much;weâ€™re just returning z. - We can add more local variables using brackets, just make sure you use semi-colons: quadadd a b c d = let { e = a + b; f = c + d } in e + f - This has exactly the same effect as this, where we nest â€˜inâ€™clauses: quadadd a b c d = let e = a + b in Computer Science / Software Engineering Notes Network let f = c + d in e + f - The difference between â€˜letâ€™+ â€˜inâ€™and â€˜whereâ€™is that â€˜letâ€™+ â€˜inâ€™is an expression;you can put it anywhere where an expression is expected. On the other hand, â€˜whereâ€™is syntactically bound to a function, meaning you can only use it in one place. Pattern matching - You can define a function in several parts by using pattern matching. - Pattern matching allows you to define what the parameter should look like, and then act accordingly. - For example: n o t : : B o o l - > B o o l n o t F a l s e = T r u e n o t T r u e = F a l s e - If the parameter is â€˜Falseâ€™, return â€˜Trueâ€™. If the parameter is â€˜Trueâ€™, return â€˜Falseâ€™. - Letâ€™s try a more complex example: n o n z e r o : : I n t - > B o o l n o n z e r o 0 = F a l s e n o n z e r o _ = T r u e - That underscore _ is a wildcard. Any value can go there, within reason. You use this when you donâ€™t really care whatâ€™s there. - Again, the order of the pattern matches matter, just like guards. - Letâ€™s try another: ( & & ) : : B o o l - > B o o l - > B o o l T r u e & & b = b F a l s e & & _ = F a l s e - If I were to use the function like: T r u e & & ( ( 5 * 3 + 1 ) < ( 8 * 2 - 6 ) ) - The value of the expression on the right will be localised within the variable â€˜bâ€™in the code above. - With structure p attern s, you can apply pattern matching with structures, like lists or tuples. - For example, if you had: f o o ( x , _ ) = x - This function f o o , returns the first element of the input tuple:x. - The second element of the input tuple would be ignored, as there is a wildcard there. Computer Science / Software Engineering Notes Network - Another example: f o o [ 5 , a , 4 ] = a - As long as the first and third elements are â€˜5â€™and â€˜4â€™, the result will be the second element. - This also works with nested tuples and nested lists. - With list p attern s, you can use the â€˜consâ€™operator with pattern matching. - For example: t a i l ( x : x s ) = x s - If you did tail [1,2,3], then the variable â€˜xâ€™would be â€˜1â€™and â€˜xsâ€™would be [2,3]. - Basically, (x:xs) splits the list into its head and its tail. Sometimes, this makes implementing recursive algorithms easier. It also validates input to only lists with at least one element. - If ( x : x s ) = [ 1 , 2 , 3 ] then x = 1 , x s = [ 2 , 3 ] - If ( x : x s ) = [ 4 ] then x = 4 , x s = [ ] - You can go further and add more, like: a d d F i r s t T w o F r o m L i s t ( x : y : x s ) = x + y o n e E l e m e n t O n l y ( x : [ ] ) = T r u e - With co mp o site p attern s, you can use all of the above together with multiple arguments. - Here is an example of that: f e t c h : : I n t - > [ a ] - > a f e t c h _ [ ] = e r r o r \" E m p t y L i s t \" f e t c h 0 ( x : _ ) = x f e t c h n ( _ : x s ) = f e t c h ( n - 1 ) x s - As you can see, pattern matching can be applied to any parameter, and can be used as extensively as you need, within reason. - Strin g p attern s are just normal patterns, but with strings. - Remember, theyâ€™re just lists of Chars. Therefore, list patterns can be used with strings. - For example, ( _ :â€˜aâ€™:_ ) matches strings whose second character is â€˜aâ€™. - The pattern [] matches the empty string. Lambda expressions - Lambda expressions are simple ways of creating quick functions without a name. - For example, you could create an add function and apply it like: a d d : : I n t - > I n t - > I n t a d d x y = x + y a d d 5 6 Computer Science / Software Engineering Notes Network - But did you know that you could also do: ( \\ x - > \\ y - > x + y ) 5 6 o r ( \\ x y - > x + y ) 5 6 - You donâ€™t have to name it at all;you can just create it quickly, use it, and never refer to it again. - This is particularly useful when using functions like â€˜mapâ€™. Operator sections - An operator section is an infix operator in prefix form: - ( âŠ™) , ( x âŠ™) , ( âŠ™x ) - Letâ€™s say you wanted a function that just adds 5 to stuff. - You could write: a d d 5 : : I n t - > I n t a d d 5 x = x + 5 - But why write that when you can write: ( + 5 ) - This is because something like â€œ5 + 4â€ can be written as â€œ(+) 5 4â€. - So you can cut that expression in half and get just the part where it adds 5:â€œ(+5) 4â€ (because, remember, everything is curried in Haskell). - It works on both sides, so (+5) and (5+) are the same. List Comprehension and Recursion List comprehension - You can generate a list, a bit like set comprehension. - { ğ‘¥ 2 | ğ‘¥ âˆˆ { 1 , . . . , 5 } } - [ x ^ 2 | x < - [ 1 . . 5 ] ] - Those two expressions yield the same thing, except one is set theory and one is Haskell. - Letâ€™s pick it apart: - [ x ^ 2 | x < - [ 1 . . 5 ] ] - The blue part is what will be in each element of the list. - The red part are the conditions that each element must abide by. Computer Science / Software Engineering Notes Network - You can even add more variables and conditions: - [ ( x , y ) | x < - [ 1 . . 5 ] , y < - [ 6 . . 1 0 ] , x > y ] - In general, list comprehensions look like this: - [ e x p | c o n d 1 , c o n d 2 , c o n d 3 , . . . , c o n d n ] Zips - There is a zip function, which lets you zip two lists together into tuples. - Example: > z i p [ ' a ' , ' b ' , ' c ' ] [ 1 , 2 , 3 , 4 ] [ ( ' a ' , 1 ) , ( ' b ' , 2 ) , ( ' c ' , 3 ) ] - This is pretty handy;you could use a list comprehension over the zipped list. - For example, you could pair up elements of a list: p a i r s : : [ a ] - > [ ( a , a ) ] p a i r s x s = z i p x s ( t a i l x s ) > p a i r s [ 1 , 2 , 3 , 4 ] [ ( 1 , 2 ) , ( 2 , 3 ) , ( 3 , 4 ) ] - Then you could use a list comprehension to check if a list is sorted: s o r t e d : : O r d a = > [ a ] - > B o o l s o r t e d x s = a n d [ x â‰¤y | ( x , y ) < - p a i r s x s ] Recursion - Recursion is simple in Haskell. - Just refer to the same function again within the function body: f a c 0 = 1 f a c n = n * f a c ( n - 1 ) - If you need to recurse through a data structure, like a list, just do the following: l e n g t h : : [ a ] - > I n t l e n g t h [ ] = 0 l e n g t h ( x : x s ) = 1 + l e n g t h x s - By doing this, â€˜xâ€™is the first element of the list and â€˜xsâ€™is the rest of the list. - You can also use wildcards: d r o p 0 x s = x s d r o p _ [ ] = [ ] d r o p n ( _ : x s ) = d r o p ( n - 1 ) x s Computer Science / Software Engineering Notes Network - You can also have mutual recursion, where two recursive functions recurse each other! e v e n s : : [ a ] - > [ a ] e v e n s [ ] = [ ] e v e n s ( x : x s ) = x : o d d s x s o d d s : : [ a ] - > [ a ] o d d s [ ] = [ ] o d d s ( x : x s ) = e v e n s x s - These are the 5 steps to not lose marks in the exam better recursion: - Step 1:Define the Type - Step 2:Enumerate the Cases - Step 3:Define the simple (base) cases - Step 4:Define the other (inductive) cases - Step 5:Generalise and Simplify Tail recursion - Tail recursion is a special kind of recursion that calls itself at the end (the tail) of the function in which no computation is done after the return of the recursive call. - In other words, the recursive calls do all the work, and at the end, the answer is just returned, as opposed to normal recursion, where a big computation is built up through recursive calls, then at the end, the whole thing is computed and returned. - Typically, tail recursion uses accumulators, whereas normal recursion does not. - Here are two kinds of factorial function, one with tail recursion and one without: Tail recursio n No tail recursio n f a c ' : : I n t - > I n t - > I n t f a c ' a c c 0 = a c c f a c ' a c c n = f a c ' ( n * a c c ) ( n - 1 ) f a c ' 1 5 - - S t a r t f a c ' 5 4 f a c ' 2 0 3 f a c ' 6 0 2 f a c ' 1 2 0 1 f a c ' 1 2 0 0 1 2 0 f a c : : I n t - > I n t f a c 0 = 1 f a c n = n * f a c ( n - 1 ) f a c 5 - - S t a r t 5 * f a c 4 5 * 4 * f a c 3 5 * 4 * 3 * f a c 2 5 * 4 * 3 * 2 * f a c 1 5 * 4 * 3 * 2 * 1 * f a c 0 5 * 4 * 3 * 2 * 1 * 1 1 2 0 - In the tail recursion version, all of the work is done in the accumulator as each of the steps go by. Then, once the base case is reached, the answer is simply spat out. Computer Science / Software Engineering Notes Network - In the non-tail recursion version, no work is done by the recursive steps;itâ€™s just building up one big sum. Once the base case is reached, one huge computation is calculated and returned. - Thatâ€™s the difference;tail recursion does stuff in steps, whereas normal recursion does it in one huge chunk at the end! - They still do the same thing, except tail recursion uses an accumulator. - Sometimes, the tail recursion way is easier to understand. - Because of the way Haskell works, these two methods work exactly the same way, even under the hood! - Thatâ€™s because Haskell is lazy, and wonâ€™t calculate things unless it really has to. - So Haskell wonâ€™t calculate the value of the accumulator until the very end, which is what the non-tail recursion method does. Computer Science / Software Engineering Notes Network Higher Order Functions - A higher order function is a function that either takes in a function or returns a function. - The following are higher order functions: f u n c 1 : : ( a - > b ) - > a f u n c 2 : : a - > ( b - > a ) Map, filter and fold - Why do we have higher order functions? - One of the reasons why is for the â€˜mapâ€™function. - The â€˜mapâ€™function allows you to apply a function to all elements of a functor. - For example, you could use â€˜mapâ€™to add 5 to all elements of a list: m a p ( \\ x - > x + 5 ) [ 1 , 2 , 3 ] m a p ( + 5 ) [ 1 , 2 , 3 ] - - r e s u l t i s [ 6 , 7 , 8 ] - Another example is â€˜filterâ€™, which allows you to filter out things from a list: f i l t e r ( \\ x - > x = = 5 ) [ 1 , 2 , 3 , 4 , 5 ] f i l t e r ( = = 5 ) [ 1 , 2 , 3 , 4 , 5 ] - - r e s u l t i s [ 5 ] - Another example is â€˜foldâ€™. There are two fold functions:â€˜foldlâ€™and â€˜foldrâ€™. - â€˜foldlâ€™is left-associative, and â€˜foldrâ€™is right-associative. - Here is an example that sums a list: f o l d r ( \\ x a c c - > x + a c c ) 0 [ 1 , 2 , 3 ] f o l d r ( + ) 0 [ 1 , 2 , 3 ] - The first argument is a lambda with an element and an accumulator, the second argument is the starting value of the accumulator and the third argument is the list to fold. - â€˜foldlâ€™works pretty much the same way as â€˜foldrâ€™, except for the different associativity, but there may be some efficiency gains. However, be wary of infinite lists with â€˜foldlâ€™! Dollar operator - The operator $ takes in a function and an argument and applies the function to the argument. - Why not just run the function? - The reason why is $ associates to the right. - Hereâ€™s an example:letâ€™s say you wanted to run the following: s q r t 3 ^ 2 + 4 ^ 2 Computer Science / Software Engineering Notes Network - The answer you want is 5, but instead, you get 19. Why? - Haskell is left-associative, so it does sqrt 3^2 first, then adds it to 4^2. - To make it right, use this: s q r t $ 3 ^ 2 + 4 ^ 2 - The $ operator associates to the right, so 3^2 + 4^2 will be calculated first, then itâ€™ll be square-rooted. Function composition - Another operator is the function composition (dot) operator. - You can use it like maths, to join two functions together. - So instead of o d d x = n o t ( e v e n x ) - Instead, you can write: o d d = n o t . e v e n - Thatâ€™s basically English! Declaring Types Declaring Types and Classes â€˜typeâ€™ - You can define type synonyms, so that you can call a data structure a name that makes more sense. - For example, we donâ€™t say a character array (unless youâ€™re working with C), we say â€˜stringâ€™. - We donâ€™t use [Char], we use String. - Here is how you can define your own synonyms: t y p e P o s = ( I n t , I n t ) - So now, instead of saying (Int, Int), you can say Pos instead. - If you want to parameterise the class you want, you can do that as well: t y p e P a i r a b = ( a , b ) - So now, when you do function type declarations, you can feed in the class parameters of the synonym â€˜Pairâ€™, and those classes will be validated inside the tuple. Computer Science / Software Engineering Notes Network - For example: type Pair a b = (a, b) f :: ( Integral a, Integral b) => Pair a b -> Pair a b f (x,y) = (x+ 1 , y+ 1 ) - The function â€˜fâ€™will only work if a pair of integers are inputted, because it takes in â€œPair Integral Integralâ€. - Additionally, nesting types are allowed, but recursing them is not. t y p e P o s = ( I n t , I n t ) t y p e T r a n s l a t i o n = P o s - > P o s - - N i i i c e e ! ! t y p e T r e e = ( I n t , [ T r e e ] ) - - O h h n o o ! ! â€˜dataâ€™ - If you want to define a completely new type, and not just a synonym, then you can use the â€˜dataâ€™keyword. - To instantiate a new type, you have to use itâ€™s constructor. - Example: d a t a P a i r = P a i r I n t I n t I n t | P a i r S t r i n g S t r i n g S t r i n g - To instantiate a new Pair, you need to use either the constructor PairInt, or PairString, then the values. This ensures type validation. - Hereâ€™s whatâ€™s allowed and not allowed with our example: - - R I G H T P a i r I n t 5 6 P a i r S t r i n g \" f i l t h y a c t s \" \" a t a r e a s o n a b l e p r i c e \" - - W R O N G P a i r I n t \" k i l l e r q u e e n \" \" b i t e s t h e d u s t \" P a i r S t r i n g 4 4 - You can have lots of constructors separated by bars |. - Like type synonyms, data types can have parameters too, like: d a t a M a y b e a = N o t h i n g | J u s t a - You can also do recursive types with â€˜dataâ€™: data BinaryTree a = Leaf a | Node a ( BinaryTree a) ( BinaryTree a) Node 4 ( Node 3 ( Leaf 1 ) ( Leaf 2 )) Leaf 5 -- you could have this, for example Computer Science / Software Engineering Notes Network - You can even do pattern matching: g e t L e f t B r a n c h : : B i n a r y T r e e a - > B i n a r y T r e e a g e t L e f t B r a n c h ( L e a f a ) = L e a f a g e t L e f t B r a n c h ( N o d e a x y ) = x â€˜newtypeâ€™ - This is like a cross between â€˜typeâ€™and â€˜dataâ€™. You can only have one constructor, and you can only provide one type after a constructor. - For example: n e w t y p e P a i r = P a i r ( I n t , I n t ) - This means itâ€™s more than just renaming something, because you still need the constructor, but itâ€™s more restrictive than â€˜dataâ€™because you only have one constructor and one type. â€˜classâ€™ - You know how each class has their own function that applies to every type that inherits that class? - For example: - the class Eq has == - the class Ord has < and > - the class Num has + and - - the class Functor has â€˜mapâ€™(more on that later!) - Letâ€™s make our own, using the â€˜classâ€™keyword! - Example: c l a s s T r e e a w h e r e f l a t t e n : : a b - > [ b ] - This is our â€˜Treeâ€™class that represents trees. It has a method â€˜flattenâ€™, which flattens all of the values in the tree nodes. - The â€˜aâ€™in â€˜Tree aâ€™represents the data structure that inherits the â€˜Treeâ€™class, for example â€˜BinaryTreeâ€™. - The â€˜bâ€™in â€˜a bâ€™represents the type of the node values in the data type â€˜aâ€™. - So now, we have our class, like Eq or Ord. - But Eq and Ord have their own instances, for example all numbers inherit the class Eq or Ord. How do we create data structures that inherit our class Tree? â€˜instanceâ€™ - We can use the â€˜instanceâ€™keyword to pair our BinaryTree data type to our Tree class: i n s t a n c e T r e e B i n a r y T r e e w h e r e f l a t t e n ( L e a f v ) = [ v ] Computer Science / Software Engineering Notes Network f l a t t e n ( N o d e v x y ) = [ v ] + + f l a t t e n x + + f l a t t e n y - In our instance block, we have to define the functions weâ€™ve declared in the class block. - We need to define it in terms of BinaryTree, because thatâ€™s what weâ€™re making an instance of. - So â€˜classâ€™defines what Tree does generally with data type â€˜aâ€™, and â€˜instanceâ€™ substitutes in â€˜BinaryTreeâ€™for â€˜aâ€™and tells Haskell what to do if the program treats BinaryTree like a Tree. - If that doesnâ€™t make any sense, then go ahead and try creating your own class with data types. Youâ€™ll learn much better by doing, not reading! Trees Red-Black Trees - Remember red-black trees from Algorithmics? - The root is black - All the leaves are black - If a node is red, it has black children - Every path from any node to a leaf contains the same number of black nodes - Here is an example of a balanced red-black tree: - How do we do this in Haskell? - Like this: d a t a R B T r e e a = L e a f a | R e d N o d e a ( R B T r e e a ) ( R B T r e e a ) | B l a c k N o d e a ( R B T r e e a ) ( R B T r e e a ) - We can also define a function called â€˜blackHâ€™which finds the maximum number of black nodes from any path - from the root to the leaf. b l a c k H ( L e a f _ ) = 0 Computer Science / Software Engineering Notes Network b l a c k H ( R e d N o d e _ l r ) = m a x l r w h e r e m a x l r = m a x ( b l a c k H l ) ( b l a c k H r ) b l a c k H ( B l a c k N o d e _ l r ) = 1 + m a x l r w h e r e m a x l r = m a x ( b l a c k H l ) ( b l a c k H r ) Abstract Syntax Trees - You can create a tree that represents syntax of an algebra. - For example, you could do arithmetic: data Expr = Val Int | Add Expr Expr | Sub Expr Expr eval :: Expr -> Int eval ( Val n) = n eval ( Add e1 e2) = eval e1 + eval e2 eval ( Sub e1 e2) = eval e1 - eval e2 -- Example eval ( Add ( Val 10 ) ( Val 20 )) -- Would return 30 eval ( Sub ( Val 20 ) ( Val 5 )) -- Would return 15 - Even propositional logic: -- Data type for propositional expression data Prop = Const Bool | Var Char | Not Prop | And Prop Prop | Imply Prop Prop -- Data type for a single pair of variable to value type Subst = [ ( Char , Bool ) ] -- Takes a var, a substitution pair and returns the value that the var is paired with find :: Char -> Subst -> Bool find k t = head [ v | (k',v) <- t, k == k' ] -- Evaluates a propositional expression eval :: Subst -> Prop -> Bool eval s ( Const b) = b eval s ( Var c) = find c s eval s ( Not p) = not $ eval s p eval s ( And p q) = eval s p && eval s q eval s ( Imply p q) = eval s p <= eval s q -- Examples eval [] ( And ( Const False ) ( Const True )) -- Would return False eval [('a', True )] ( Var 'a') -- Would return True Functors - A functor is simply a class, like Ord or Num, that says â€œthis can be mapped overâ€. - For example, a list is a type of functor, because you can use the â€œmapâ€ function on it. Computer Science / Software Engineering Notes Network - The only function in this class is â€œfmapâ€. â€œmapâ€ is the same as â€œfmapâ€, except that itâ€™s exclusively for lists. - Here is the class for Functor, as well as some instances: class Functor f where fmap :: (a -> b) -> f a -> f b instance Functor [] where fmap = map instance Functor Maybe where fmap _ Nothing = Nothing fmap g ( Just x) = Just (g x) - When you create an instance of Functor in some class you make, make sure it abides by the following laws: - Law 1: f m a p i d = i d - Law 2: f m a p ( g . h ) = f m a p g . f m a p h - Here is an illustration of f m a p ( + 3 ) ( J u s t 2 ) - If you still donâ€™t understand functors, I strongly suggest this article about Functors, Applicatives and Monads. It has really simple explanations and images to explain these complex ideas! - A tree is also a type of data structure. We could create a map function that works on trees, thereby making trees a functor! - We could have something like: i n s t a n c e F u n c t o r B i n a r y T r e e w h e r e f m a p g ( L e a f v ) = L e a f ( g v ) f m a p g ( N o d e v x y ) = N o d e ( g v ) ( f m a p g x ) ( f m a p g y ) Computer Science / Software Engineering Notes Network - Boom! Now we can use fmap on BinaryTrees if we wanted to, like: f m a p ( \\ x - > x + 1 0 ) ( N o d e 5 ( L e a f 3 ) ( L e a f 6 ) ) - - t h i s w i l l r e t u r n : N o d e 1 5 ( L e a f 1 3 ) ( L e a f 1 6 ) ) Directions, trails and zippers - We can define the direction in which we can traverse through a tree, like this: data Direction = L | R type Directions = [ Direction ] elemAt :: Directions -> Tree a -> a elemAt _ ( Leaf x) = x elemAt ( L :ds) ( Node _ l _) = elemAt ds l elemAt ( R :ds) ( Node _ _ r) = elemAt ds r elemAt [] ( Node x _ _) = x -- Examples elemAt [ L ] ( Node 5 ( Leaf 3 ) ( Leaf 4 )) -- returns 3 elemAt [ R , L ] ( Node 5 ( Leaf 6 ) ( Node 2 ( Leaf 8 ) ( Leaf 9 ))) -- returns 8 - How do we know how far weâ€™ve gone? - We can build up a trail so we know the direction weâ€™ve gone in: type Trail = [ Direction ] goLeft :: ( Tree a, Trail ) -> ( Tree a, Trail ) goLeft ( Node _ l _ , ts) = (l , L :ts) goRight :: ( Tree a, Trail ) -> ( Tree a, Trail ) goRight ( Node _ _ r , ts) = (r , R :ts) -- Examples (goLeft . goRight) (a, []) -- for some tree 'a', this will return (b, [L, R]) where 'b' is the subtree if you go right, then left in 'a' - You can also make a function to follow a trail, if you like. - But what if you want to go back up? You donâ€™t remember the parent when you go left or right. - You can make it so that Direction stores the parent as well: data BinaryTree a = Leaf a | Node a ( BinaryTree a) ( BinaryTree a) deriving ( Show ) data Direction a = L ( BinaryTree a) | R ( BinaryTree a) deriving ( Show ) type Trail a = [ Direction a ] parentInDirection ( L p) = p parentInDirection ( R p) = p goLeft :: ( BinaryTree a, Trail a) -> ( BinaryTree a, Trail a) goLeft ( Leaf x, ts) = ( Leaf x, ts) goLeft ( p@( Node _ l _) , ts) = (l, ( L p):ts) Computer Science / Software Engineering Notes Network goRight :: ( BinaryTree a, Trail a) -> ( BinaryTree a, Trail a) goRight ( Leaf x, ts) = ( Leaf x, ts) goRight ( p@( Node _ _ r) , ts) = (r, ( R p):ts) goUp :: ( BinaryTree a, Trail a) -> ( BinaryTree a, Trail a) goUp (tree, ts) = (parent, restOfList) where latestMove = head ts restOfList = tail ts parent = parentInDirection latestMove -- Example (goUp . goLeft) (tree, []) -- this will return (tree, []) because goLeft followed by goUp effectively does nothing, like taking a step forward then taking a step back ZIPPER MAN! - This concept of pairing one piece of data with another in a list of pairs has a name in functional programming:itâ€™s called a zip p er type. Graphs - Functional programming is crap for modelling graphs. - Usually, if you wanted to work with graphs in a functional programming paradigm, youâ€™d use a hybrid language, like JavaScript or F#. - In Haskell, weâ€™ll look at three ways to try and model graphs. Indexed collections of Nodes, Edges - This is a nonstructural approach. - This is the easiest and most intuitive way to do things. - Basically, you have a function that takes in a node and returns a list of adjacent nodes, like so: g r a p h : : I n t - > [ I n t ] - Actually, the lovely developers over at Haskell HQ have already done this! In the Data.Graph package, they have: t y p e T a b l e a = A r r a y V e r t e x a t y p e G r a p h = T a b l e [ V e r t e x ] - Where â€˜Vertexâ€™is some ID of the node, like an Int or something. - They also provide functions for working with graphs, like searching, building, fetching, reversing etc. - This is alright, but you canâ€™t weigh the edges and the performance is slow. Structured data type with cyclic dependencies - This has limitations for modifying the graphs. Computer Science / Software Engineering Notes Network - Itâ€™s similar to the method from before, except weâ€™re not using an array;weâ€™re using a cyclic dependency. - Whatâ€™s a cyclic dependency? Think of it like this: - What is the value of x s = 0 : x s ? - Itâ€™s an infinite string of zeros:[ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 . . . ] - Next:what is the value of xs where x s = 0 : y s , y s = 1 : x s ? - This oneâ€™s a bit more tricky, but itâ€™s [ 0 , 1 , 0 , 1 , 0 , 1 , 0 , 1 . . . ] - So you see, weâ€™re defining these lists in a â€œcyclicâ€ manner, because they go back and forth, around and around, like a circle. - What if we applied a cyclic dependency to our graph structure? - First of all, to make it simpler, letâ€™s assume that each node only has one edge. - Letâ€™s create a data structure for this: d a t a G r a p h a = G N o d e a ( G r a p h a ) - Where: - G N o d e a ( G r a p h a ) - The value of the node - Adjacent node;the node that this node can go to - Now, we want a function that converts a table of nodes to a Graph structure: m k G r a p h : : [ ( a , I n t ) ] - > G r a p h a - Where our input table looks a little something like this: ID Value Next n o de 1 London 3 2 Berlin 4 3 Rome 2 4 Morioh 1 - The implementation can go a little something like this: m k G r a p h : : [ ( a , I n t ) ] - > G r a p h a m k G r a p h t a b l e = t a b l e ' ! ! 0 w h e r e t a b l e ' = m a p ( \\ ( x , n ) - > G N o d e x ( t a b l e ' ! ! n ) ) t a b l e - You can generalise this so that a node can have lots of outgoing edges: data GGraph a = GGNode a [ GGraph a] mkGGraph :: [ (a, [ Int ]) ] -> GGraph a mkGGraph table = table' !! 0 Computer Science / Software Engineering Notes Network where table' = map (\\(x,ns) -> GGNode x (map (table'!!) ns ) table - With this method, you donâ€™t need to name nodes and itâ€™s fast to go from node to node. However, you canâ€™t build this structure incrementally;you have to build it all at once. Inductive approach with graph constructors - This provides inductive structure and pattern matching. - This is the library Data.Graph.Inductive.Graph. - Here, each node has an Int ID, like last time. - The graph is built one node at a time, and all the nodes link together to form a graph, kind of like how you could use a : b : c to form a list [ a , b , c ] . - There are two key things to building a graph using this approach: e m p t y : : G r a p h a b e m b e d : : C o n t e x t a b - > G r a p h a b - > G r a p h a b - The â€˜emptyâ€™value is an empty graph with no nodes or edges. - The â€˜embedâ€™function embeds a new node into an existing graph and returns the new graph. - So, whatâ€™s a context? - A context is a data structure that represents a node, on its own, outside a graph. - It stores the node ID, the node label, the outgoing edges and incoming edges. t y p e A d j b = [ ( b , N o d e ) ] t y p e C o n t e x t a b = ( A d j b , N o d e , a , A d j b ) - Where Adj is: - t y p e A d j b = [ ( b , N o d e ) ] - The label of the edge - The node on the end of this edge - And Context is: - t y p e C o n t e x t a b = ( A d j b , N o d e , a , A d j b ) - Incoming edges - Node ID of this node - Label of this node - Outgoing edges - An example of a graph with this is: Computer Science / Software Engineering Notes Network - Of course, there are other ways to make this graph, which will all work if implemented. - Not only can you build up a graph node by node, you can decompose a graph node by node as well. - FGL provides a function â€˜matchâ€™: m a t c h : : N o d e - > G r a p h a b - > D e c o m p a b - Which takes in a node to remove, the graph itself, and returns the graph without the node. - Decomp is: t y p e D e c o m p a b = ( M a y b e ( C o n t e x t a b ) , G r a p h a b ) - Where: - the first element of the pair is either the removed node or nothing. - the second element of the pair is the graph without the node. - Thereâ€™s also a function called matchAny: m a t c h A n y : : G r a p h a b - > D e c o m p a b - If you donâ€™t really care which node you take out;itâ€™ll remove any. - With these, you can create a map function for your graph: g m a p : : ( C o n t e x t a b - > C o n t e x t c b ) - > G r a p h a b - > G r a p h c b g m a p f g | i s E m p t y g = e m p t y | o t h e r w i s e = e m b e d ( f c ) ( g m a p f g ' ) w h e r e ( c , g ' ) = m a t c h A n y g Computer Science / Software Engineering Notes Network Evaluation Order and Laziness Equational reasoning - Equational reasoning simply means proving things by following equations through. - For example, you could prove n o t ( n o t F a l s e ) is F a l s e by simplifying it to n o t ( T r u e ) , then simplifying it further to F a l s e . - However, weâ€™re going a little deeper by using proof by induction. - Proof by induction: - To prove P(n) for all n, we prove P(0) and we then prove for any k that P(k+1) holds under the assumption that P(k) holds. - Say we had the natural number data type, like this: d a t a N a t = Z e r o | S u c c N a t - Where 0 is Zero, 1 is Succ Zero, 2 is Succ Succ Zero etc. - We also have an add function: a d d : : N a t - > N a t - > N a t a d d Z e r o m = m a d d ( S u c c n ) m = S u c c ( a d d n m ) - How do we prove that â€˜addâ€™is associative with proof by induction? - We need to prove it for a base case and for an inductive case. - We want to prove:a d d x ( a d d y z ) = a d d ( a d d x y ) z B ase C ase In ductive C ase a d d Z e r o ( a d d y z ) - - S T A R T a d d ( a d d Z e r o y ) z - - G O A L a d d Z e r o ( a d d y z ) = { d e f n o f a d d } a d d y z = { d e f n o f a d d ' b a c k w a r d s ' } a d d ( a d d Z e r o y ) z a d d ( S u c c x ) ( a d d y z ) - - S T A R T a d d ( ( a d d ( S u c c x ) y ) z ) - - G O A L a d d ( S u c c x ) ( a d d y z ) = { d e f n o f a d d } S u c c ( a d d x ( a d d y z ) ) = { i n d u c t i v e h y p o t h e s i s } S u c c ( a d d ( a d d x y ) z ) = { d e f n o f a d d ' b a c k w a r d s ' } a d d ( S u c c ( a d d x y ) z ) = { d e f n o f a d d ' b a c k w a r d s ' } a d d ( ( a d d ( S u c c x ) y ) z ) - You can even perform proofs on structures! Computer Science / Software Engineering Notes Network - To see these proofs, look at the slides. Redex - A redex, or â€œreducible expressionâ€, is simply a part of an expression that you need to know before you compute the full expression. - For example, if you were to calculate the expression: - (1 + 5) * (6 - 3) - There are three redexâ€™s inside this: - (1 + 5) * (6 - 3) - 1 + 5 - (1 + 5) * - 6 - 3 - Because Haskell is fully functional, expressions like â€œ5 +â€ is actually a function, so to do, say, â€œ5 + 6â€, Haskell finds the function â€œ5 +â€, then uses that function on â€œ6â€. - Therefore, even in an expression like â€œ5 + 6â€, there is a redex â€œ5 + 6â€ because Haskell needs to know that function before computing the rest of the expression. Beta-reduction - Beta reduction is a process that converts a function call into an expression. - Youâ€™re familiar with lambda expression, right? You should be;I covered it a few sections ago. - If not, it goes like this: , where the first â€˜xâ€™after the lambda is the parameter andÎ»ğ‘¥. ğ‘¥ everything after the dot is the function body. The syntax can vary, but thatâ€™s the gist of it. - You can call a lambda function like this: , which is .( Î»ğ‘¥. ğ‘¥ + ğ‘¥) ( 5 ) 5 + 5 - If you wanted multiple parameters, you would do , which is( Î»ğ‘¥. Î»ğ‘¦. ğ‘¥ + ğ‘¦) ( 4 6 ) 4 + 6 (itâ€™s similar to how Haskell curries everything). - When we converted to , weâ€™ve done beta reduction.( Î»ğ‘¥. ğ‘¥ + ğ‘¥) ( 5 ) 5 + 5 - More generally, if we had a function and an input , to beta reduce, just take theÎ»ğ‘¥. ğ‘¥ ğ‘¦ function body and replace all with .ğ‘¥ ğ‘¦ - Just like in our example, we took the function body and replaced all with .ğ‘¥ + ğ‘¥ ğ‘¥ 5 - Hereâ€™s a more complex example:how do we reduce... - ( Î»ğ‘¥. ( Î»ğ‘¥. ğ‘¥) ğ‘¥ + ğ‘¦) ( Î»ğ‘¥. ğ‘¥ ğ‘¥) - ...using beta reduction? - This is a big jump, but if we break this up and do this step-by-step, itâ€™s not so bad. - First of all, letâ€™s isolate the function body: - ( Î»ğ‘¥. ğ‘¥) ğ‘¥ + ğ‘¦ - Now letâ€™s split this up into its terms: - ( Î»ğ‘¥. ğ‘¥) - ğ‘¥ - ğ‘¦ - Our argument is . Which of those terms are ?Î»ğ‘¥. ğ‘¥ ğ‘¥ ğ‘¥ Computer Science / Software Engineering Notes Network - Just the one, right? So we replace that: - ( Î»ğ‘¥. ğ‘¥) - Î»ğ‘¥. ğ‘¥ ğ‘¥ - ğ‘¦ - Now we work back into the function body... - ( Î»ğ‘¥. ğ‘¥) ( Î»ğ‘¥. ğ‘¥ ğ‘¥) + ğ‘¦ - ... and weâ€™re done. Call-By-Name - Outermost reduction with no reduction under lambda is more commonly known as call-by-n ame reduction. This is used by Haskell. - In laymanâ€™s terms, this means that function calls are processed without processing or even looking at the arguments. - For example, letâ€™s say we have an infinite list, and we want to get the first element of that infinite list: t a k e 1 [ 1 , 2 , 3 , 4 . . . ] - Call-by-name doesnâ€™t care about the infinite list;it wonâ€™t try to process it. Instead, itâ€™ll just perform the function â€œtake 1â€ and take 1 element off of that list. The result will simply be [1]. - Because of this, Haskell can efficiently process information by lazy evaluation. - Haskell also uses something called grap h reductio n to perform lazy evaluation. - Remember in beta-reduction where an expression is repeated wherever the function parameter is? - With graph reduction, only one instance of the expression is stored and multiple pointers to that expression are used instead. - Therefore, any reductions performed on the single copy will permeate throughout all references of that expression. - You want an example of graph reduction? Alright:consider this Haskell line: r e p l i c a t e 1 0 ( 6 Ï€^ 2 ) - With call-by-name, we donâ€™t care what that argument is. We just create a list of 10 unevaluated expressions of . But since theyâ€™re all unevaluated, if we tried to display6 Ï€ 2 this list, wouldnâ€™t we have to calculate 10 times for each element?6 Ï€ 2 Computer Science / Software Engineering Notes Network - You are wrong! Remember, Haskell uses graph reduction. There is only one ;every6 Ï€ 2 element in that list is a pointer to that one . Therefore, we only need to calculate6 Ï€ 2 once, then all the pointers will update.6 Ï€ 2 Call-By-Value - Innermost reduction with no reduction under lambda is more commonly known as call-by-value reduction. This is used by languages like C++, Java, Python etc. - In English, this means that arguments are processed before the function is called. - For example, letâ€™s say we have an infinite list, and we want to get the first element of that infinite list: t a k e 1 [ 1 , 2 , 3 , 4 . . . ] - Call-by-value will try and process that infinite list, and itâ€™ll be there forever because thereâ€™s no end to it. Therefore, this function call will not end. Modularity - Letâ€™s just say we want a Haskell program that yields us a list of 300 1â€™s. Hereâ€™s two different possible solutions: So lutio n A (the go o d o n e) So lutio n B (the crap o n e) o n e s = 1 : o n e s t a k e 0 _ = [ ] t a k e _ [ ] = [ ] t a k e n ( x : x s ) = x : t a k e ( n - 1 ) x s t a k e 3 0 0 o n e s r e p l i c a t e 0 _ = [ ] r e p l i c a t e n x = x : r e p l i c a t e ( n - 1 ) x r e p l i c a t e 3 0 0 1 - Solution A splits the code into data (ones) and control (take). - Solution B blends the two together. - Solution A is better because itâ€™s more modulated, therefore: â— itâ€™s easier to debug â— parts of it are reusable â— easier to read and understand â— you split the problem up into subproblems, making it easier to program - The point is, Haskell allows modularity through laziness. Computer Science / Software Engineering Notes Network - You can use this for other examples too, like creating a list of all prime numbers using the Sieve of Eratosthenes (data), then taking the first 100 primes (control). Strict application - If you wanted to, you could scrap all of this and use strict application. - Basically, it tells Haskell to evaluate the expression on the right before applying the function. Itâ€™s used with the â€˜$!â€™operator. - Itâ€™s mainly used for space efficiency, and it allows for true tail recursion. - Example: Step C o de 1 s q u a r e $ ! ( 1 + 2 ) 2 s q u a r e $ ! ( 3 ) 3 s q u a r e 3 4 9 Computer Science / Software Engineering Notes Network Interpreters and Closures Part 1 - Substitutions - Weâ€™re going to write an interpreter in Haskell! - What language should we interpret? - How about lambda calculus? The rules are pretty simple there. Lambda calculus - What is lambda calculus? - Itâ€™s a formal system to express functions. - There are only three rules:variables on their own, function application and function abstraction. - Here they are: Rule D escrip tio n Fo rmat Examp le Variable Itâ€™s just a variable on itâ€™s own. Just some symbol on itâ€™s own x x y Function abstraction A function definition A lambda character, followed by a variable name, followed by a full stop, followed by the function body which is another lambda expression Î»( s o m e v a r i a b l e ) . ( s o m e l a m b d a e x p r e s s i o n ) They can be curried to have more parameters Î»( s o m e v a r i a b l e ) . Î»( a n o t h e r v a r i a b l e ) . Î»( y e t a n o t h e r v a r i a b l e ) â€¦ . ( s o m e l a m b d a e x p r e s s i o n ) Instead of dots, you can use an arrow, if Î»x . x Î»x . Î»y . y Î»x . Î»x . x Î»x . Î»y . Î»z . y O R Î»x â†’ x Î»x â†’ Î»y â†’ y Î»x â†’ Î»x â†’ x Î»x â†’ Î»y â†’ Î»z â†’ y Computer Science / Software Engineering Notes Network you wish Function application A function being applied to some expression Itâ€™s just an expression separated by an expression with a space ( a l a m b d a e x p r e s s i o n ) ( a n o t h e r l a m b d a e x p r e s s i o n ) It represents calling a function with some input Î»x . x x Î»x . Î»y . y y x y Î»x . Î»y . y Î»y . Î»y . y - Despite how simple it is, it can encode a lot of information. - It can encode arithmetic, logic, structured data etc. - A variable x is bo un d in the term Î»x â†’ e and the sco p e of the binding is the expression e. - A variable y is free in the term Î»x â†’ y because it was initialised outside of the scope of this function abstraction. - A lambda expression with no free variables is called clo sed. Beta reduction syntax - Remember beta reduction a few sections ago? - If not, scroll up and read it. Itâ€™s literally right above this section. - Weâ€™re going to express beta reduction like this: - ( Î»x â†’ e 1 ) e 2 - will be rewritten as - e 1 [ x : = e 2 ] - Read it like â€œIn e 1 , replace all x with e 2 â€. Alpha conversion - We have - ( Î»x â†’ ( Î»y â†’ x ) ) y - which is basically - ( Î»y â†’ x ) [ x : = y ] - which becomes - ( Î»y â†’ y ) - Everything seems fine and dandy. - But what if we have this: - Î»y â†’ ( ( Î»x â†’ ( Î»y â†’ x ) ) y ) - it will become Computer Science / Software Engineering Notes Network - Î»y â†’ ( Î»y â†’ y ) - Ah... thatâ€™s not exactly what we wanted. That y is now bound by the inner function, not the outer function like itâ€™s supposed to. - If only we could rename the parameter of the inner function... - What? Thatâ€™s already a thing? - Alpha conversion renames an inner function so that you donâ€™t get variable capture, which is a phenomenon that occurs in substitution when a free variable becomes bound by the term you substitute it into. - So if we rename the inner y to z, we can have: - Î»y â†’ ( ( Î»x â†’ ( Î»z â†’ x ) ) y ) - it will become - Î»y â†’ ( Î»z â†’ y ) - Everything is fixed thanks to alpha-conversion! - With all of these rules, you can now build your interpreter! - If you really want to know how, look at these slides. Part 2 - Machines - Plot twist! Part 1 is a load of crap and you shouldnâ€™t implement interpreters that way. - Well, you can, but itâ€™s really inefficient. Environments - We have this lambda expression: - ( Î»x - > x ) e - With normal beta reduction, this becomes just - e - But what if we were lazy and just said - x ( b u t w e k n o w t h a t e i s s u b s t i t u t e d a s x ) - Weâ€™re not explicitly replacing anything, weâ€™re just storing a record of the substitutions. - Therefore, we could look up stuff when we need it. - This is the concept of an en viro n men t. - An environment records bindings of variables to expressions, just like a mapping. - For example, if we had the expression - ( Î»x - > e 1 ) e 2 - ... and we wanted to use beta reduction with environments, we could go about this like: Exp ressio n En viro n men t B efo re beta reductio n ( Î»x - > e 1 ) e 2 Nothing A fter beta reductio n e 1 x is mapped to e 2 Computer Science / Software Engineering Notes Network - How do we write this in proper syntax? - Weâ€™ll write - e | E - to represent an expression e in the environment E. - So now, our beta reduction looks like: - ( Î»x - > e 1 ) e 2 | E âŸ¼ e 1 | E [ x : = e 2 ] - Where E [ x : = e 2 ] means environment E updated with the new binding of x to the expression e 2 . - Note that e 1 may now contain free occurrences of x . - That means we should have a rule like: - x | E âŸ¼ â€œ l o o k u p x i n E â€ | E - ... so that we can look up free occurrences of x when we get to them. Frames - Another improvement to our interpreter is to make it so that it only focuses on the subterm that needs evaluating next. - Keep in mind that everything that follows is tailored to a call-by-value strategy. - Have a think about what we actually do when we look at an expression: Exp ressio n What do we do ? x Itâ€™s just a variable. We canâ€™t simplify this down any further, so just leave it. Itâ€™s terminated. Î»x - > e This is just a lambda term on itâ€™s own. We canâ€™t simplify this any further, so leave it. Itâ€™s terminated. ( Î»x - > e 1 ) e 2 This is an application, which can be reduced. First of all, we reduce e2, then we perform beta reduction. e 1 e 2 We can simplify this, also. If weâ€™re doing left-most, we simplify e1 then e2, and if weâ€™re doing right-most, we simplify e2 and then e1. We will be doing left-most for now. - So thereâ€™s two possibilities of simplifying things down:either we have a lambda application, or a normal application with two expressions. - When we simplify the lambda application, we take out the e2 and leave the rest, leaving just - ( Î»x - > e 1 ) [ - ] - Where [ - ] is a hole or an empty void where we took out e2 and can plug in other expressions. - Once weâ€™ve simplified e2, we plug it back in and we perform beta reduction. Computer Science / Software Engineering Notes Network - When we simplify the application, we take out e1, leaving just - [ - ] e 2 - Once weâ€™ve simplified e1, we plug it back in and take out e2, leaving: - e 1 [ - ] - Once weâ€™ve simplified e2, we plug that back in and we can continue. - All of these expressions with [ - ] in them are called frames. - Theyâ€™re sort of like a â€œsnapshotâ€ of what we havenâ€™t evaluated yet as we venture deeper into the lambda expression. - Think of it like a Java call stack, how â€˜framesâ€™are stacked when you call lots of methods. - A stack of frames is called a co n tin uatio n . - Just for referenceâ€™s sake, a value is a terminated expression;one that cannot simplify anymore. Continuations - Now that we have continuations, letâ€™s rewrite our reductions as follows: - e | E | K âŸ¼ e â€™ | E â€™ | K â€™ - Where K is our continuation. - When do we push a new frame onto the stack? - We push when we have an unevaluated expression that we want to simplify. - e 1 e 2 | E | K âŸ¼ e 1 | E | ( [ - ] e 2 ) : : K - When do we pop a new frame off the stack? - If our focussed expression is terminated (which will be represented with a V), thereâ€™s three possibilities: - K is empty - Weâ€™re finished;the evaluation has terminated - K has [ - ] e 2 at the top - We now need to take out e2 and put back e1 (now called V because we should have simplified it), by popping the e2 frame and pushing a new frame with V on it: - V | E | [ - ] e 2 : : K âŸ¼ e 2 | E | V [ - ] : : K - K has ( Î»x - > e 1 ) [ - ] at the top - We need to perform beta reduction: - V | E | ( Î» x - > e ) [ - ] : : K âŸ¼ e | E [ x : = V ] | K CEK-machines - Letâ€™s combine these three ideas into one set of rules. - This is called a CEK-Machine, and it stands for: - C ontrol - Environment Computer Science / Software Engineering Notes Network - Kontinuation - Each of these make up the syntax weâ€™ve been using all this time: - e | E | K g - Hereâ€™s the rules, in all their glory: # C E K C E K 1 x E K â€œlookup x in Eâ€ E K 2 e1 e2 E K e1 E [-] e2 :: K 3 V E [-] e :: K e E V [-] :: K 4 V E ( Î»x -> e) [-] :: K e E [x := V] k R1: x | E | K âŸ¼ â€œlookup x in Eâ€ | E | K R2: e1 e2 | E | K âŸ¼ e1 | E | [-] e2 :: K R3: V | E | [-] e :: K âŸ¼ e | E | V [-] :: K R4: V | E | ( Î»x -> e) [-] :: K âŸ¼ e | E [x := V] | K Rule # Exp lan atio n 1 If we see a single variable on its own, look it up in the environment and replace it with that corresponding expression. 2 If we see an application, take out the left expression for simplifying and put the right expression onto the stack. 3 If we have a fully simplified expression and thereâ€™s an application on the stack that has a left-side missing, put the left side back and take out the right-side for simplifying. 4 If we have a fully simplified expression and thereâ€™s a lambda application on the stack that has a right-side missing, perform beta reduction on our terminated value and that function application. - But not too much glory! Thereâ€™s a problem. Closures - Whatâ€™s the problem? - Have a look at this expression: - ( Î»z - > Î»x - > ( Î»y - > y z x y ) ( Î»x - > z x ) ) e 1 e 2 - This looks daunting at first, but let me split this up for you: - ( Î»z - > Î»x - > ( Î»y - > y z x ) ( Î»x - > z x ) ) e 1 e 2 - Remember that z is e1 and x is e2. - Now, I want you to focus on this part here: - Î»y - > y z x Computer Science / Software Engineering Notes Network - The y here is bound to the yellow function above, so: - ( Î»x - > z x ) z x - Now z is being substituted into this function as x, so now x is being rebound to the value of z, which is e1. - But that means our interpreter will change the x on the right of the expression into e1, when it should be e2. - When a function is used as a value, we need to keep track of the bindings of its free variables at the point of use. - We need to think of a function as a closed entity. - How do we do this? - We use closures! - A clo sure is a pairing of a function to the bindings in the current environment. - The syntax is:c l ( Î»x - > e , E ) - We pass these around instead of values. - Think of a closure like local scoped variables in a method in Java. - Hereâ€™s the new grammar weâ€™re using: - W : : = c l ( Î»x - > e , E ) - F : : = W [ - ] | [ - ] e E - K : : = [ ] | F : : K - E : : = âˆ… | E [ x : = W ] - W represents a closure or a terminated value. - F is a frame - K is a continuation - E is an environment - Hereâ€™s the rules, but rewritten with closures: # C E K C E K 1 x E1 K Î»x -> e E2 K 2 e1 e2 E K e1 E [-] e2 E :: K 3 Î»x -> e E K cl( Î»x -> e, E) E K 4 W E1 [-] e E2 :: K e E2 W [-] :: K 5 W E1 cl( Î»x -> e, E2) [-] :: K e E2 [x := W] K R1 : x | E1 | K âŸ¼ Î»x -> e | E2 | K where lookup x in E1 is cl( Î»x -> e, E2) R2 : e1 e2 | E | K âŸ¼ e1 | E | [-] e2 E :: K R3 : Î»x -> e | E | K âŸ¼ cl( Î»x -> e, E) | E | K R4 : W | E1 | [-] e E2 :: K âŸ¼ e | E2 | W [-] :: K R5 : W | E1 | cl( Î»x -> e, E2) [-] :: K âŸ¼ e | E2 [x := W] | K Computer Science / Software Engineering Notes Network Rule # Exp lan atio n 1 A simple variable look-up, this time with closures. Iâ€™m not sure why the slides made it so complicated;itâ€™s just a look-up as far as I can see. 2 If there is an application, pluck out the left-side and put the rest on the continuation stack along with a copy of the current environment. 3 If there is a function, wrap it in a closure along with a copy of the current environment. 4 If we have a terminated value and a right-side only application is on top of the stack, then take the right-side to simplify and put the left-side (our terminated value) back into the stack. 5 If we have a terminated value and a closure on the stack, then pop the closure off the stack, perform beta reduction with the closure function and the terminated value and add the new pairing to the environment. Example sequence - In case you forgot, this is supposed to interpret lambda expressions. - Letâ€™s watch this evaluate the term: - ( Î» x â†’ Î» y â†’ x ) e 1 e 2 - Given that e1 and e2 are terminated values: Step # Rule # used C E K Explanation 1 N/A ( Î»x â†’ Î»y â†’ x) e1 e2 âˆ… [] Nothing has been done yet; this is like our â€œinitial stateâ€. 2 R2 ( Î»x â†’ Î»y â†’ x) e1 âˆ… ([-] e2 âˆ…) :: [] We have an application, so R2 is applied. The left side of the application is plucked and stored in control, and a new frame is created and pushed, which stores the other side along with a copy of the environment at the time of creation. 3 R2 ( Î»x â†’ Î»y â†’ x) âˆ… ([-] e1 âˆ…) :: ([-] e2 âˆ…) :: [] There is another application, so R2 is used again. Like with the previous step, the left-hand side is stored and the right-hand side is Computer Science / Software Engineering Notes Network pushed as a frame, with a copy of the environment with it. 4 R3 cl( Î»x â†’ Î»y â†’ x, âˆ…) âˆ… ([-] e1 âˆ…) :: ([-] e2 âˆ…) :: [] A raw function is found! We apply R3. We create and store a closure of this function with the current environment. 5 R4 e1 âˆ… cl( Î»x â†’ Î»y â†’ x, âˆ…) [-] :: ([-] e2 âˆ…) :: [] We have a closure, and an application is on the stack. We use R4. This is just like the rule before closures, but this time itâ€™s with closures; we put the left expression back and we now take out the right expression. 6 R5 Î»y â†’ x [x := e1] ([-] e2 âˆ…) :: [] We have a terminated value and a closure on the stack, so we use R5. We take out the environment in the frame and use that (which was nothing to begin with), then we add a new pairing: the parameter of the function in the closure to the expression in the control section . The expression in the function of the closure goes into our control section. 7 R3 cl( Î»y â†’ x, [x := e1]) [x := e1] ([-] e2 âˆ…) :: [] Weâ€™ve found another raw function, so yet again, we put a closure around it and add a copy of the current environment to it. 8 R4 e2 âˆ… cl( Î»y â†’ x, [x := e1]) [-] :: [] Weâ€™ve got a closure and another application on the stack, so we use R4. Simply, we put the left-side expression back and take out the right-side Computer Science / Software Engineering Notes Network expression to simplify. 9 R5 x [x := e1, y := e2] [] We have a terminating value and a closure on the stack, so we use R5. Again, the environment in the closure is used and we add an extra pairing of the closure functionâ€™s parameter to the expression in the control section. The body of the closure function is now in the new control section. 10 R1 e1 [x := e1, y := e2] [] We have a single value we need to convert, so we use R1, which looks up the value of x and replaces it with what it finds. DONE - Weâ€™re finished;the expression simplifies down to just e 1 ! Computer Science / Software Engineering Notes Network Functional I/O and Monads I/O in Haskell IO a - Pure function:a function whose output solely depends on the input. Nothing else affects the output. - This is not true with Java methods, because the state of the object also affects the output. This is called a side-effect. - A function with a side-effect in Haskell is a little hacky. Basically, we input a state along with the input, and we get a state out along with the output: - Letâ€™s just say we had a type World that represents the system state. - We could define a transformation: - t y p e I O = W o r l d - > W o r l d - We need an output too, so we should instead put: - t y p e I O a = W o r l d - > ( a , W o r l d ) - Our function also needs to take arguments, so we can do: - C h a r - > I O a - Which would be the same as: - C h a r - > W o r l d - > ( a , W o r l d ) - So, what can you do with the World? Stop time? - No. It actually doesnâ€™t exist. - But IO does. - So when you have a function like C h a r - > I O I n t , this actually means this: - ... and the Int you get out is determined by the Char input and the system state. - The difference between I n t and I O I n t is that: - I n t is just a regular type that can store an integer Computer Science / Software Engineering Notes Network - I O I n t is a function that takes in a system state and returns an integer value and the modified system state Actions - These are all actions: - I O C h a r - I O F l o a t - I O ( ) - I O a - An action is an expression of type I O a . - There are three basic actions: - g e t C h a r : : I O C h a r (read a single character from stdin) - p u t C h a r : : C h a r - > I O ( ) (takes a char and returns an action that writes that char to the standard output) - r e t u r n : : a - > I O a (casts a pure expression into an expression with IO) - When we see an action of type I O ( ) , it doesnâ€™t return anything;its only purpose is to change the state in some way. Do notation - How do we sequence actions, for example how do we call getChar 3 times in a row to read a string of length 3? - We can use do notation! - â€˜doâ€™notation looks like this: d o p 1 < - a c t 1 p 2 < - a c t 2 ...p n < - a c t n a c t f i n a l - The actions are listed from a c t 1 to a c t n , and any result is pattern matched and bound to p1 to pn. - The final action â€˜a c t f i n a l â€™must not be bound and is typically a â€˜returnâ€™action. - Each action must be column aligned. - If an action doesnâ€™t return anything, then you donâ€™t need the â€œp <-â€ bit. - The type of the overall expression is the type of the final action. - This is an example of an action that reads three characters, and returns the first and third characters: f i r s t T h i r d : : I O ( C h a r , C h a r ) Computer Science / Software Engineering Notes Network f i r s t T h i r d = d o x < - g e t C h a r g e t C h a r y < - g e t C h a r r e t u r n ( x , y ) - This is an example of an action that writes a string to standard output: p u t S t r : : S t r i n g â†’ I O ( ) p u t S t r [ ] = r e t u r n ( ) p u t S t r ( x : x s ) = d o p u t C h a r x p u t S t r x s - This is an example of an action that writes a string to the standard output with a new line: p u t S t r L n : : S t r i n g â†’ I O ( ) p u t S t r L n x s = d o p u t S t r x s p u t C h a r ' \\ n ' - This is an example of an action reading a line from standard input: g e t L i n e : : I O S t r i n g g e t L i n e = d o x < - g e t C h a r i f x = = ' \\ n ' t h e n r e t u r n [ ] e l s e d o x s < - g e t L i n e r e t u r n ( x : x s ) - The one above might take a bit of explaining: - The â€˜if, then, elseâ€™section is all one expression with type I O S t r i n g and is thus an action. - The reason why we do a second â€˜doâ€™at the end is because â€˜elseâ€™only expects one action after itself, and by using â€˜doâ€™we encapsulate those two lines into one action. Main Function, File Handling, Random Numbers - Did you know thereâ€™s a main function in Haskell? - Itâ€™s of the type I O ( ) - Haskell also provides basic actions for reading and writing files: t y p e F i l e P a t h = S t r i n g r e a d F i l e : : F i l e P a t h - > I O S t r i n g w r i t e F i l e : : F i l e P a t h - > S t r i n g - > I O ( ) Computer Science / Software Engineering Notes Network a p p e n d F i l e : : F i l e P a t h - > S t r i n g - > I O ( ) - As you would expect, reading files are done lazily. - The System.IO module introduces the IO type and the Handle type, so you can choose whether you want to read/write from stdin, stdout, stderr or a file. - You can also have random actions, from the System.Random module. - You can get a random number with: - r a n d o m I O : I O a - You can get a random number in a range with: - r a n d o m R I O : : ( a , a ) - > I O a Applicatives - A quick refresher on functors:theyâ€™re classes that can be mapped over with fmap. Lists, Justs, Trees, theyâ€™re all functors. - Applicative is a class, like Functor. In fact, itâ€™s the next step up from functors. - With applicatives, the function is now wrapped in a context! - The class looks like this: c l a s s F u n c t o r f = > A p p l i c a t i v e f w h e r e p u r e : : a - > f a ( < * > ) : : f ( a - > b ) - > f a - > f b - The p u r e function takes any pure value and adds a context to it. Nothing is changed. - For example: - p u r e x = [ x ] (for lists) - p u r e x = L e a f x (for trees) - p u r e x = J u s t x (for maybes) - p u r e x = r e t u r n x (for IO) - The <*> operator unpacks the function from the context and the argument, applies the function to the argument, and then packs the result back into a context and returns it. - So applicatives are just functors, but the function is in a context as well. - Hereâ€™s an illustration of J u s t ( + 3 ) < * > J u s t 2 Computer Science / Software Engineering Notes Network - With this, we can create maps that handles multiple inputs! - For example: p u r e ( \\ x y - > x + y ) < * > [ 1 , 2 , 3 ] < * > [ 1 0 , 2 0 , 3 0 ] - So, what does this actually simplify to? - You know that Haskell is left-associative, so the order goes like this: - p u r e ( \\ x y - > x + y ) < * > [ 1 , 2 , 3 ] < * > [ 1 0 , 2 0 , 3 0 ] - Where red is first and blue is second. - p u r e takes the input and adds a context to it, so it becomes - [ \\ x y - > x + y ] < * > [ 1 , 2 , 3 ] < * > [ 1 0 , 2 0 , 3 0 ] - Next, the red expression is simplified by unpacking the function and the argument and applying them. - However, notice that the function requires two parameters, but weâ€™re only giving it one in this red expression. What happens when you give a function too little parameters? It returns a partially applied function! - So for each number (1, 2 and 3), that lambda on the left will not return a number;itâ€™ll return a partially applied function for each, so the result will be: - [ ( \\ y - > 1 + y ) , ( \\ y - > 2 + y ) , ( \\ y - > 3 + y ) ] - Making our total expression: - [ ( \\ y - > 1 + y ) , ( \\ y - > 2 + y ) , ( \\ y - > 3 + y ) ] < * > [ 1 0 , 2 0 , 3 0 ] - Now we just have to simplify the blue bit. Weâ€™re comfortable with one function being wrapped in a list, but what about multiple? - What the list applicative does in this case is it unpacks all the functions, and it applies the first with all the argument values, the second with all the argument values etc. then it unions all those results into one big list. - So the result of this would be: - [ 1 1 , 2 1 , 3 1 , 1 2 , 2 2 , 3 2 , 1 3 , 2 3 , 3 3 ] - Which is our final answer. - Did you know that IO is also an applicative? - p u r e in terms of IO is the same as r e t u r n . - <*> in terms of IO is the following: ( < * > ) : : I O ( a - > b ) - > I O a - > I O b Computer Science / Software Engineering Notes Network m g < * > m x = d o g < - m g x < - m x r e t u r n ( g x ) - In English, <*> takes two actions as input: - An action that returns a function from a to b - An action that returns a value a - The operator unpacks the function and the value by performing the actions in a â€˜doâ€™ block. It then runs the function on the value and returns it out of the â€˜doâ€™block. - Because r e t u r n is the same as p u r e , r e t u r n ( g x ) will return an action, or an I O b expression, because r e t u r n and p u r e packs pure values into contexts (in this case, IO). - How is this useful? - We can use this to make a function - g e t C h a r s : : I n t - > I O S t r i n g - ... that reads the given number of Chars from stdin. g e t C h a r s : : I n t - > I O S t r i n g g e t C h a r s 0 = r e t u r n \" \" g e t C h a r s n = p u r e ( : ) < * > g e t C h a r < * > g e t C h a r s ( n - 1 ) - We use : to stick all the characters together into a string, and we wrap it into an IO using p u r e ( : ) . - Sure, we could also do g e t C h a r s : : I n t - > S t r i n g g e t C h a r s 0 = \" \" g e t C h a r s n = g e t C h a r : g e t C h a r s ( n - 1 ) - But that doesnâ€™t give us an action. We can use the one that uses applicatives in a â€˜doâ€™ block, like this: d o s t r < - g e t C h a r s 5 r e t u r n s t r - If you canâ€™t be bothered to write p u r e for the first argument all the time, use <$>: - p u r e a < * > f b - is the same as - a < $ > f b - Lastly, like with functors, there are applicative laws that you need to uphold when implementing them: - Law 1: Iden tity p u r e i d < * > x = x Computer Science / Software Engineering Notes Network - Law 2: Ho mo mo rp hism p u r e ( g x ) = p u r e g < * > p u r e x - Law 3 (symmetry): x < * > p u r e y = p u r e ( \\ g - > g y ) < * > x - Law 4 (tran sitivity): x < * > ( y < * > z ) = ( p u r e ( . ) < * > x < * > y ) < * > z - If you still donâ€™t understand applicatives, I strongly suggest this article. - Why are functors a superclass of applicatives? - If a class C is an applicative, then that means it has an implementation for the functions p u r e and < * > . - f m a p can be defined using only p u r e and < * > : - f m a p f x = = p u r e f < * > x - Therefore class C can be a functor. Monads - Monads take it a step even further: class Applicative m => Monad m where return :: a -> m a (>>=) :: m a -> (a -> m b) -> m b return = pure - So what does this actually mean? - Donâ€™t worry too much about r e t u r n ;thatâ€™s just the same as p u r e . - The real defining feature of monads is the > > = operator (called â€˜bindâ€™). - The > > = operator takes a wrapped value and a function that returns a wrapped value, and applies the wrapped value to the function and returns another wrapped value. Computer Science / Software Engineering Notes Network - Donâ€™t forget, like with functors and applicatives, there are monad laws too. - Law 1: C o mp o sitio n / Left Iden tity r e t u r n x > > = f = f x - Law 2: Iden tity / Right Iden tity m x > > = r e t u r n = m x - Law 3: A sso ciativity ( m x > > = f ) > > = g = m x > > = ( \\ x - > ( f x > > = g ) ) - Why are applicatives a superclass of monads? - If a class C is a monad, then that means it has an implementation for the functions r e t u r n and > > = . - p u r e and < * > can be defined using only r e t u r n and > > = : - p u r e = r e t u r n - f < * > x = f > > = \\ g - > - x > > = \\ y - > - r e t u r n ( g y ) - Therefore class C can be an applicative. - That sounds so pointless;how could we ever use monads? Computer Science / Software Engineering Notes Network - Monads are mainly used to abstract away boilerplate code, so that we can turn a complicated sequence into a succinct pipeline. - When you ask a computer to calculate the next three possible moves, would you write code along the lines of â€œFind the positions in the next move, but donâ€™t go off the board or walk into any other pieces! Then, go through each of those new positions and find the next move of all of those, also making sure you donâ€™t go off the board or walk into any other pieces! Then, go through each of those new positions and find the next move, and also make sure you donâ€™t go off the board or walk into any other pieces etc.â€ - Look how long and tedious that is when all you needed was â€œFind the positions in the next three movesâ€. Thatâ€™s the sort of thing that monads solve. - Remember, monads are just a design pattern. Thereâ€™s nothing new;itâ€™s just a different, more clean way of doing things. - Hereâ€™s examples of uses of monads:error handling, chaining and non-determinism. Use of monads:Error handling - We have this data type: d a t a E x p r = V a l I n t | D i v E x p r E x p r - How do we evaluate it? Like this? e v a l : : E x p r - > I n t e v a l ( V a l n ) = n e v a l ( D i v x y ) = e v a l x ` d i v ` e v a l y - What if we divide by 0? Itâ€™ll stop working. - How do we handle the case where we divide by 0? - We could return M a y b e I n t instead of I n t , so we could return N o t h i n g if we divide by 0. - Did you know that M a y b e is a monad? - M a y b e s handle monads like this: J u s t x > > = f N o t h i n g > > = f f x (will return wrapped value) N o t h i n g - So if nothing is passed in, nothing comes out, but if a Just is passed in, the function applies normally and another Just comes out. - Rewriting this with monads, we can do: e v a l : : E x p r - > M a y b e I n t e v a l ( V a l n ) = J u s t n e v a l ( D i v x y ) = e v a l x > > = ( \\ n - > e v a l y > > = ( \\ m - > s a f e d i v n m ) ) ( b r a c k e t s n o t n e c e s s a r y ) Computer Science / Software Engineering Notes Network s a f e d i v : : I n t - > I n t - > M a y b e I n t s a f e d i v _ 0 = N o t h i n g s a f e d i v n m = J u s t ( n ` d i v ` m ) - So whatâ€™s actually going on here? - s a f e d i v is pretty easy;weâ€™re dividing the numbers in a Just if the second number is not zero. If the second number is zero, we return nothing. - e v a l uses lambdas as functions, and uses s a f e d i v at the end to return another wrapped value. - This is good because if any â€˜layerâ€™of those lambdas returns N o t h i n g , then everything after it will be N o t h i n g as well. This error handling is woven into monads, so we can abstract away that stuff out of our e v a l function. - We can actually rewrite e v a l to make it easier to read: e v a l : : E x p r - > M a y b e I n t e v a l ( V a l n ) = J u s t n e v a l ( D i v x y ) = d o n < - e v a l x m < - e v a l y s a f e d i v n m - Look familiar? This is the same â€˜doâ€™notation that we used for IO. - This is because â€˜doâ€™notation is actually syntactic sugar for that lambda stuff we did above. - If we used â€˜doâ€™notation for IO, does that mean IO is a monad? - Yes. IO is a monad. Use of monads:Chaining - You can also chain functions together with monads, like this: J u s t 1 0 > > = ( \\ x - > J u s t ( x + 1 0 ) ) > > = ( \\ x - > J u s t ( x * 2 ) ) - Letâ€™s go over this bit-by-bit. - Remember, Haskell is left-associative so the expression is parsed like this: - J u s t 1 0 > > = ( \\ x - > J u s t ( x + 1 0 ) ) > > = ( \\ x - > J u s t ( x * 2 ) ) - Where red is parsed first and blue is parsed second. - The bind unwraps the first argument, J u s t 1 0 to 1 0 , and passes it through the given function, \\ x - > J u s t ( x + 1 0 ) . This results in: - J u s t 2 0 - So now our expression is: - J u s t 2 0 > > = ( \\ x - > J u s t ( x * 2 ) ) - Again, we unpack Just 20 to 20. Then we pass it into the function, leaving us with: - J u s t 4 0 Computer Science / Software Engineering Notes Network - This is our final answer! The functions x + 1 0 and x * 2 are chained together with bind, so the operation here is practically just 2 ( x + 1 0 ) . Use of monads:Non-determinism - What about lists? Theyâ€™re monads too, you know. - How do lists handle bind? They do it like this: x s > > = f = [ y | x < - x s , y < - f x ] - En glish, p lease: - This means the function is performed on each element of the list, and all of those results are collected or â€œunionedâ€ into one big list. - For example, the expression: - [ 3 , 4 , 5 ] > > = \\ x - > [ x , - x ] - ... will evaluate to: - [ 3 , - 3 , 4 , - 4 , 5 , - 5 ] - This is great because it allows us to do non-deterministic computations with very little code! - If you read the slides (or turned up to the lectures), youâ€™ll remember the Knightâ€™s Tour example. - Basically, we have a knight on a chessboard and we want to know the possible places it can move. - If youâ€™ve never played chess before (play it, itâ€™s hype) a knight can move one space left, up, down or right, then another two spaces in a perpendicular direction. For example, a knight could move one space up, then two spaces right. - Here, weâ€™ll model it in Haskell: type KnightPos = ( Int , Int ) moveKnight :: KnightPos -> [ KnightPos ] moveKnight (c,r) = filter onBoard [ (c+ 2 ,r -1 ), (c+ 2 ,r+ 1 ), (c -2 ,r -1 ), (c -2 ,r+ 1 ), (c+ 1 ,r -2 ), (c+ 1 ,r+ 2 ), (c -1 ,r -2 ), (c -1 ,r+ 2 ) ] where onBoard (c,r) = c `elem` [ 1..8 ] && r `elem` [ 1..8 ] - In this code, the moveKnight method takes in a position and returns the possible positions of the next move. Thatâ€™s great, but what if we want to know the possible positions of the next 3 moves? - Monads! i n 3 m o v e s : : K n i g h t P o s - > [ K n i g h t P o s ] i n 3 m o v e s s t a r t = r e t u r n s t a r t > > = m o v e K n i g h t > > = m o v e K n i g h t > > = m o v e K n i g h t - Letâ€™s go over this... - Haskell is left-associative: - r e t u r n s t a r t > > = m o v e K n i g h t > > = m o v e K n i g h t > > = m o v e K n i g h t Computer Science / Software Engineering Notes Network - The r e t u r n function is just like p u r e ;it wraps s t a r t into a list, the monad weâ€™re working with. - [ s t a r t ] > > = m o v e K n i g h t > > = m o v e K n i g h t > > = m o v e K n i g h t - The expression [ s t a r t ] > > = m o v e K n i g h t will unpack [ s t a r t ] to get just s t a r t , then it will put it into m o v e K n i g h t and that function will return a list of all the possible positions to move to from s t a r t within one turn. - [ a l l p o s s i b l e m o v e s i n o n e t u r n ] - This makes our expression: - [ a l l p o s s i b l e m o v e s i n o n e t u r n ] > > = m o v e K n i g h t > > = m o v e K n i g h t - Remember how lists work with monads? The bind operator runs the function on all of the elements of the list, then collects them all together into one big list. - So now, in the blue expression, m o v e K n i g h t is being called on all elements of the [ a l l p o s s i b l e m o v e s i n o n e t u r n ] list. That means all the results weâ€™ll get will be all the possible moves in two turns! - [ a l l p o s s i b l e m o v e s i n t w o t u r n s ] - So our expression will become: - [ a l l p o s s i b l e m o v e s i n t w o t u r n s ] > > = m o v e K n i g h t - Like before, m o v e K n i g h t is being called on all elements of [ a l l p o s s i b l e m o v e s i n t w o t u r n s ] , so all the results will be the possible moves in three turns. - [ a l l p o s s i b l e m o v e s i n t h r e e t u r n s ] - Now weâ€™re done! As you can see, if we can make a move in one turn, we can chain these together with bind and see where weâ€™ll be in three turns by using list monads. Since lists can process things in a non-deterministic fashion, we can calculate different possible â€œpathsâ€. - If you wanted to, you could see how many moves you could make in n turns just by repeating the bind call n times. - Remember, if you ever get confused about functors, applicatives and monads, just remember this picture: - Weâ€™re not done with monads just yet. Sorry! - Thereâ€™s two more functions:m a p M and f i l t e r M . mapM - The mapM function goes like this: Computer Science / Software Engineering Notes Network m a p M : : M o n a d m = > ( a - > m b ) - > [ a ] - > m [ b ] m a p M f [ ] = r e t u r n [ ] m a p M f ( x : x s ) = d o y < - f x y s < - m a p M f x s r e t u r n ( y : y s ) - So what does this mean? - You pass in a function that takes pure values and outputs wrapped values: - f - ... and you also pass in a list of pure values: - [ x 1 , x 2 , x 3 , x 4 , . . . , x n ] - mapM will then do the following: do y1 <- f x1 y2 <- f x2 y3 <- f x3 ...yn <- f xn return (y1 : y2 : y3 : ... : yn : []) - Basically, mapM is like normal map but with the benefit of monads (error handling, non-determinism etc.) - So, for example, if we did: - m a p M ( \\ x - > [ x , - x ] ) [ 1 , 2 , 3 ] - We will get the result: - [ [ 1 , 2 , 3 ] , [ 1 , 2 , - 3 ] , [ 1 , - 2 , 3 ] , [ 1 , - 2 , - 3 ] , [ - 1 , 2 , 3 ] , [ - 1 , 2 , - 3 ] , [ - 1 , - 2 , 3 ] , [ - 1 , - 2 , - 3 ] ] - Because that map is pretty much doing the same as: do x1 <- (\\x -> [x,-x]) 1 x2 <- (\\x -> [x,-x]) 2 x3 <- (\\x -> [x,-x]) 3 return (x1 : x2 : x3 : []) - Still donâ€™t get what this is saying? Donâ€™t worry;letâ€™s go through this. - Iâ€™ll use a table and steps to illustrate this properly: Step # C o de Values Exp lan atio n 1 do x1 <- (\\x -> [x,-x]) 1 x2 <- (\\x -> [x,-x]) 2 x3 <- (\\x -> [x,-x]) 3 x1 = N/A x2 = N/A x3 = N/A Weâ€™ve just entered the â€˜doâ€™block. In the â€˜Codeâ€™column, the red highlighted bit shows the lines where the computation has already processed. Computer Science / Software Engineering Notes Network return (x1 : x2 : x3 : []) 1 do x1 <- [1, -1] x2 <- [2, -2] x3 <- [3, -3] return (x1 : x2 : x3 : []) x1 = N/A x2 = N/A x3 = N/A Just to make things a bit easier for us, letâ€™s simplify those lambda calls on the right. Itâ€™s easy to see what they return, and itâ€™lljust complicate things if we leave them. It doesnâ€™t change anything. Normally, GHCI will lazily evaluate them, but just for the exampleâ€™s sake, weâ€™ve simplified those now. 2 do x1 <- [1, -1] x2 <- [2, -2] x3 <- [3, -3] return (x1 : x2 : x3 : []) x1 = 1 x2 = N/A x3 = N/A Now, weâ€™re looking at the first line. Remember how list monads work? The bind operator runs the function on all the values within the list, so the function will run twice here: one with 1 as the input and one with -1 as the input. But whereâ€™s the â€œfunctionâ€ here? Weâ€™re in a do block. Remember , do is syntactic sugar. If you look at this expressed with bind operators, youâ€™llsee that our â€œfunctionâ€ is just the rest of the do block, the bits that arenâ€™t highlighted in red. So now, x1 is 1. 3 do x1 <- [1, -1] x2 <- [2, -2] x3 <- [3, -3] return (x1 : x2 : x3 : []) x1 = 1 x2 = 2 x3 = N/A Again, the same thing applies and the â€œfunctionâ€ here will be run twice: one with 2 and one with -2. 4 do x1 <- [1, -1] x2 <- [2, -2] x3 <- [3, -3] return (x1 : x2 : x3 : []) x1 = 1 x2 = 2 x3 = 3 Yet again, the function will be called twice and x3 will be 3 and will soon be -3. 5 do x1 <- [1, -1] x2 <- [2, -2] x3 <- [3, -3] return (x1 : x2 : x3 : []) x1 = 1 x2 = 2 x3 = 3 [1, 2, 3] Now weâ€™re at the return . Because weâ€™re using the list monad, return will bunch these values all into a list, so itâ€™llreturn [1, 2, 3] . 6 do x1 <- [1, -1] x2 <- [2, -2] x3 <- [3, -3] return (x1 : x2 : x3 : []) x1 = 1 x2 = 2 x3 = -3 Weâ€™ve reached return; itâ€™s all over, right? Hold it! Remember how the functions are repeated for each value in the list? Now, the computation falls back to x3 . The function is called again and x3 becomes -3. 7 do x1 <- [1, -1] x1 = 1 x2 = 2 We now get [1, 2, -3] since x3 has a new value. Computer Science / Software Engineering Notes Network x2 <- [2, -2] x3 <- [3, -3] return (x1 : x2 : x3 : []) x3 = -3 [1, 2, -3] 8 do x1 <- [1, -1] x2 <- [2, -2] x3 <- [3, -3] return (x1 : x2 : x3 : []) x1 = 1 x2 = -2 x3 = N/A x3 is done for this branch, but now we go further back and x2 becomes -2. 9 do x1 <- [1, -1] x2 <- [2, -2] x3 <- [3, -3] return (x1 : x2 : x3 : []) x1 = 1 x2 = -2 x3 = 3 Now weâ€™re going back into the x3 bit and x3 is going to become 3 and -3, except this time, x2 is -2. 10 do x1 <- [1, -1] x2 <- [2, -2] x3 <- [3, -3] return (x1 : x2 : x3 : []) x1 = 1 x2 = -2 x3 = 3 [1, -2, 3] Weâ€™ve reached return again, and now weâ€™ve got [1, -2, 3] . Hopefully, you get the picture; all the combinations will be reached. Iâ€™mgoing to stop now, because this could go on for a while. filterM - The filterM function goes like this: f i l t e r M : : M o n a d m = > ( a - > m B o o l ) - > [ a ] - > m [ a ] f i l t e r M p [ ] = r e t u r n [ ] f i l t e r M p ( x : x s ) = d o b < - p x y s < - f i l t e r M p x s r e t u r n ( i f b t h e n x : y s e l s e y s ) - What does this mean? - You pass in a function that takes pure values and outputs wrapped booleans: - p - ... and you also pass in a list of pure values: - [ x 1 , x 2 , x 3 , x 4 , . . . , x n ] - filterM will then do the following: do y1 <- p x1 y2 <- p x2 y3 <- p x3 ...yn <- p xn return [ x1 if y1 is true (note: not actual Haskell!) x2 if y2 is true x3 if y3 is true Computer Science / Software Engineering Notes Network ...xn if yn is true ] - Basically, filterM is just like filter, except with the benefits of monads (error handling, non-determinism etc.) - Itâ€™s similar to mapM, except instead of mapping to another value, it uses a predicate and decides whether or not to include a value in a list depending on that predicate. - With it, you can make a function that gives you the powerset of a list: p o w e r l i s t = f i l t e r M ( \\ x - > [ T r u e , F a l s e ] ) - So, for example, if you did p o w e r l i s t [ 1 , 2 , 3 ] you would get: - [ [ 1 , 2 , 3 ] , [ 1 , 2 ] , [ 1 , 3 ] , [ 1 ] , [ 2 , 3 ] , [ 2 ] , [ 3 ] , [ ] ] - Donâ€™t get it? Donâ€™t worry;itâ€™s very similar to the previous example with mapM. - Remember the mapM example and how it went through every combination of 1, 2 and 3 being positive and negative? - Well, instead of positive and negative, think of this filterM example of being inside the list and not inside the list. - Hereâ€™s a table drawing parallels with the mapM example: Outp ut elemen ts filterM map M [ 1 , 2 , 3 ] 1 is inside 2 is inside 3 is inside 1 is positive 2 is positive 3 is positive [ 1 , 2 ] o r [ 1 , 2 , - 3 ] 1 is inside 2 is inside 3 is not inside 1 is positive 2 is positive 3 is negative [ 1 , 3 ] o r [ 1 , - 2 , 3 ] 1 is inside 2 is not inside 3 is inside 1 is positive 2 is negative 3 is positive [ 1 ] o r [ 1 , - 2 , - 3 ] 1 is inside 2 is not inside 3 is not inside 1 is positive 2 is negative 3 is negative [ 2 , 3 ] o r [ - 1 , 2 , 3 ] 1 is not inside 2 is inside 3 is inside 1 is negative 2 is positive 3 is positive [ 2 ] o r [ - 1 , 2 , - 3 ] 1 is not inside 2 is inside 3 is not inside 1 is negative 2 is positive 3 is negative Computer Science / Software Engineering Notes Network - Do you see the parallels with the mapM example? - If you understand mapM, then understanding filterM isnâ€™t that hard. Computer Science / Software Engineering Notes Network Functional Programming in Java - Ok, we have made it through Haskell, now we are going to talk about functional programming in Java - In an object-oriented programming language like Java we use objects to carry some related data. In addition, we provide methods to manipulate the data of the object. - Imagine an object that does not have any fields, i.e. that does not have any data in it. It will only consist of methods. These types of objects begin to look something like functions. - Letâ€™s think about the following questions for these objects: - Can they be considered as functions in Java? - Can we do functional programming with them? - Should we do functional programming with them? - What language support should we provide? Functions as Objects - I mentioned that we can have an object without any fields/data and imagine this object as a function - A function has no state, i.e. no fields to manipulate. This is exactly the case for this object. - Letâ€™s think about what one can do with a function - Function application - Thatâ€™s it, there is nothing more we can do with a function - Ok, so we want an object as a function, and only provide some way to apply this function. - In other words, every object will contain exactly one method and nothing else. - Why canâ€™t an object contain multiple methods? - Remember that we want to represent a function with an object - It wouldnâ€™t make sense if the object had multiple methods inside:Which one would be executed when the function is applied? - Letâ€™s look at an example of a function object in Java - We want to code the following function:It should take a number (Integer) and return the double of that number c l a s s D o u b l e { i n t a p p l y ( i n t x ) { r e t u r n 2 * x ; } } - What would the function look like in Haskell? Computer Science / Software Engineering Notes Network d o u b l e : : N u m a = > a - > a d o u b l e x = 2 * x - What are the differences between these two definitions? - In Java, the class name is the name of the function. The function is just called â€œapplyâ€. - In Haskell, you donâ€™t see â€œapplyâ€ anywhere because that is the default operation for a function - As I mentioned before, you canâ€™t do anything else with a function other than applying it - In Java, we specify with return what the output of the function is. - In Haskell, we just use â€œ=â€ to specify the output and we donâ€™t use â€œreturnâ€ - â€œreturnâ€ does exist in Haskell but it has a completely different meaning Functional Interfaces - Now we have seen the basic structure of how we can represent a function in Java - What can we do in OOP languages to represent such structures in an abstract way? - Exactly, we can define an interface. - Remember that an interface is like a contract:All classes that implement that interface have to implement the methods specified in the interface - Whenever we see an object that implements that interface, we know that this object adheres to that contract and offers all the methods specified in the interface - So letâ€™s define an interface that specifies exactly how our function objects should look like, i.e. what methods they should contain. - What method should our function object contain? - It should contain exactly one method called apply that takes an argument of some type and returns something of some type. - Should we fix those types in the interface? - Hell no! Then we would need one interface for all possible input/return type combinations you can think of. - What can we do to make it flexible such that we donâ€™t have to specify a specific type? - Exactly, we will use Generics. Our function will take some generic type and return some other generic type. They can be any type, we wonâ€™t put any restrictions on them. - So here is our interface that defines a functional object: @ F u n c t i o n a l I n t e r f a c e i n t e r f a c e F u n c t i o n < T , R > { R a p p l y ( T x ) ; } - We will call this a fun ctio n al in terface - Why? Because it is an interface that contains exactly one method. Computer Science / Software Engineering Notes Network - We will take this one step further:we will call all interfaces that contain exactly one method a functional interface. - WTF is that â€œ@FunctionalInterfaceâ€ annotation m8? - Donâ€™t worry about that, that is just for good practice. Basically, itâ€™s just saying â€œHey everyone this is an interface that contains only a single method, thus it is a functional interfaceâ€ for the information of anyone looking at the code. - It is not necessary to add this annotation and it wonâ€™t change anything at runtime. ActionListener - What are some other examples for functional interfaces? - Actually, you have already worked with loads of them. - Most famous examples are: - Runnable:contains the single method â€œrunâ€ - Comparator:contains the single method â€œcompareToâ€ - ActionListener, ChangeListener, any other Listener with a single method - Remember that Programming II coursework where you worked with ActionListener? - Iâ€™ll take this as an example. We will add an ActionListener to a button to execute some code when the button is clicked: J B u t t o n t e s t B u t t o n = n e w J B u t t o n ( \" T e s t B u t t o n \" ) ; t e s t B u t t o n . a d d A c t i o n L i s t e n e r ( n e w A c t i o n L i s t e n e r ( ) { @ O v e r r i d e p u b l i c v o i d a c t i o n P e r f o r m e d ( A c t i o n E v e n t a e ) { S y s t e m . o u t . p r i n t l n ( \" C l i c k D e t e c t e d b y A n o n C l a s s \" ) ; } } ) ; - This is an example of an anonymous inner class - It is very bulky syntactically - Letâ€™s think about which part of the syntax we can actually save/erase without changing the meaning of the code. - Why do we specify which method we implement? - ActionListener contains only one single method actionPerformed, so we cannot implement anything other than this single method - Why do we even specify that we implement an ActionListener? - The method addActionListener expects an ActionListener, so we have no choice other than providing an implementation of ActionListener - Letâ€™s re-imagine the listener and write this code in a much neater syntax using a lambda expression - We know which interface and which method we need to implement, so we are not going to write that down again - Strictly speaking, we just need to provide the name of the argument and the actual code for the function: Computer Science / Software Engineering Notes Network J B u t t o n t e s t B u t t o n = n e w J B u t t o n ( \" T e s t B u t t o n \" ) ; t e s t B u t t o n . a d d A c t i o n L i s t e n e r ( a e - > S y s t e m . o u t . p r i n t l n ( \" C l i c k D e t e c t e d b y A n o n C l a s s \" ) ) ; - Take a moment and compare this code with what we had before - It is much more elegant to write it in this way because it is straight to the point and doesnâ€™t include any repetitive syntax Lambda Syntax - For any functional interface we can now use lambda notation in Java - A lambda expression implements the functional interface for which it is used by providing code for its single method - This is what we have just seen before with the ActionListener example - The syntax is (Args) -> Body where Args is an argument list and Body is any expression, statement or block - The argument list is either a single variable name or a comma-separated list of variable names - You donâ€™t even need to specify the types of the arguments - You donâ€™t need parentheses if you only have a single argument - You can have an empty list () for when there are no arguments - In the body you can omit writing â€œreturnâ€ to return a value from an expression - Obviously the argument list and the return type of the body must match whatever is specified in the functional interface - Letâ€™s look at some more examples / / s i n g l e a r g u m e n t , n o p a r e n t h e s e s , o m i t t i n g \" r e t u r n \" s - > s . l e n g t h ( ) / / n o a r g u m e n t s , p a r e n t h e s e s n e e d e d , o m i t t i n g \" r e t u r n \" ( ) - > 4 2 / / t w o a r g u m e n t s , e x p l i c i t t y p e s , p a r e n t h e s e s n e e d e d , o m i t t i n g \" r e t u r n \" ( i n t x , i n t y ) - > x + y / / t h r e e a r g u m e n t s , i m p l i c i t t y p e s , b l o c k b o d y ( x , y , z ) - > { i f ( x > y ) r e t u r n z ; e l s e r e t u r n - z ; } More general function types - We have already seen how to implement a function object in Java Computer Science / Software Engineering Notes Network - However, can we also write a higher-order function like map? - Of course, because our Map function can take an object of type Function<T,R> as an argument - Letâ€™s define a map function for a List: i n t e r f a c e M a p L i s t < T , U > { L i s t < U > a p p l y ( F u n c t i o n < T , U > f u n , L i s t < T > l i s t ) ; } - In the package java.util.function we have common general purpose functional interfaces, all with generic types: - Letâ€™s implement MapList and look at practical examples: p u b l i c c l a s s M y M a p L i s t < T , U > i m p l e m e n t s M a p L i s t < T , U > { @ O v e r r i d e p u b l i c L i s t < U > a p p l y ( F u n c t i o n < T , U > f u n , L i s t < T > l i s t ) { L i s t < U > o u t = n e w A r r a y L i s t < > ( ) ; f o r ( T e l e m e n t : l i s t ) { o u t . a d d ( f u n . a p p l y ( e l e m e n t ) ) ; }r e t u r n o u t ; } } - Letâ€™s use this map function: M y M a p L i s t < I n t e g e r , I n t e g e r > m a p p e r = n e w M y M a p L i s t < > ( ) ; L i s t < I n t e g e r > l i s t = â€¦; / / [ 1 , 3 , 6 , 2 , 5 , 4 ] Computer Science / Software Engineering Notes Network F u n c t i o n < I n t e g e r , I n t e g e r > f u n 1 = x - > x * 2 ; L i s t < I n t e g e r > n e w L i s t 1 = m a p p e r . a p p l y ( f u n 1 , l i s t ) ; / / n e w L i s t 1 = [ 2 , 6 , 1 2 , 4 , 1 0 , 8 ] L i s t < I n t e g e r > n e w L i s t 2 = m a p p e r . a p p l y ( x - > x + 1 , l i s t ) ; / / n e w L i s t 2 = [ 2 , 4 , 7 , 3 , 6 , 5 ] - As you can see, we use lambda notation to define what the function is - We can either define a new local variable which represents our function or we can define it directly as a parameter Closure:lambda vs anonymous inner classes (AICs) - Do you remember the notation of closure in the lambda calculus? - A closure is a pair of a lambda term and bindings for all of its free variables - Even though the slides currently say something else, there is not much difference between AICs (anonymous inner classes) and lambda when it comes to closure. - One difference is the binding of the â€œthisâ€ keyword - In AICs it refers to the anonymous class - In lambda expressions it refers to the enclosing class - Another difference is that the AIC introduces a new scope whereas the lambda expression does not - Letâ€™s look at how closure works for both lambda and AICs - When we access a variable inside the lambda/AIC from the outside, it will simply get copied inside the lambda/AIC - We are actually working on a copy and not on the original variable anymore - Itâ€™s a design decision some engineers have made when they defined AICs/lambdas for Java - Because this copy-process happens, it was decided to only allow it for final or effectively final variables such that you donâ€™t really notice that you are working on a copy - In other words, you can only access final or effectively final variables inside the AIC/lambda - Now, this sounds quite easy, but you have to be a bit more careful - When you access a member variable from the enclosing class inside the lambda/AIC it turns out that it doesnâ€™t need to be final. Why is that the case? - Remember that when you access a member variable you actually access the variable via the â€œthisâ€ reference of the enclosing class - E.g. you can just write â€œxâ€ to access member â€œxâ€ but you can also write â€œthis.xâ€ to make it more explicit - Whenever you see that you are accessing a member, just imagine that the â€œthisâ€ keyword is always in front of it. Computer Science / Software Engineering Notes Network - As it turns out, the â€œthisâ€ keyword is effectively final. It never changes its reference within its scope. - Therefore, the way to actually view this case is that we are accessing some variable through the effectively final â€œthisâ€ reference of the enclosing class - The variable itself doesnâ€™t need to be final, it can be mutable. - The same applies to accessing a member variable which lives inside another object - Only the reference to the object has to be final but the member variable itself can change - In order to illustrate this letâ€™s look at two examples - The first example is : v o i d f n ( ) { i n t m y V a r = 4 2 ; S u p p l i e r < I n t e g e r > l a m b d a F u n = ( ) - > m y V a r ; / / d o e s n o t c o m p i l e b e c a u s e m y V a r i s n o t e f f e c t i v e l y f i n a l m y V a r + + ; S y s t e m . o u t . p r i n t l n ( l a m b d a F u n . g e t ( ) ) ; } - In this example, myVar will be copied inside the lambda expression - As mentioned before, we only allow this for final or effectively final variables - However, myVar is incremented after its declaration and is therefore not considered effectively final - The code will not compile - How can we get something like this working? Well, with a little workaround: p r i v a t e s t a t i c c l a s s M y C l o s u r e { p u b l i c i n t v a l u e ; p u b l i c M y C l o s u r e ( i n t i n i t V a l u e ) { t h i s . v a l u e = i n i t V a l u e ; } }v o i d f n 2 ( ) { M y C l o s u r e m y C l o s u r e = n e w M y C l o s u r e ( 4 2 ) ; S u p p l i e r < I n t e g e r > l a m b d a F u n = ( ) - > m y C l o s u r e . v a l u e ; / / c o m p i l e s b e c a u s e t h e r e f e r e n c e i s e f f e c t i v e l y f i n a l m y C l o s u r e . v a l u e + + ; S y s t e m . o u t . p r i n t l n ( l a m b d a F u n . g e t ( ) ) ; / / p r i n t s 4 3 } - In this example, the reference of myClosure will be copied inside the lambda expression - This time we donâ€™t have a problem with that because it is effectively final, i.e. after its declaration it doesnâ€™t change. - We are then accessing â€œvalueâ€ which is in the myClosure object. The contents of the object can change and do not need to be final. - As a result, the code compiles and when we run it, it will print 43. Computer Science / Software Engineering Notes Network Method references - Method references provide a means of referencing a given method as if it were a function in Java - Letâ€™s look at an example straight away: L i s t < I n t e g e r > l i s t = . . . ; / / [ - 5 , 4 , - 3 , - 2 , 1 ] L i s t < I n t e g e r > n e w L i s t 3 = m a p p e r . a p p l y ( x - > M a t h . a b s ( x ) , l i s t ) ; / / n e w L i s t 3 = [ 5 , 4 , 3 , 2 , 1 ] - Inside the lambda expression, we are just calling another function with the parameter - Thatâ€™s it, nothing more happens - Now, can we make this code more simple? - Can we somehow just pass the Math.abs function to the mapper? If yes, this would be similar to how we can pass functions around in Haskell! - Well, there is some syntactic sugar in Java for this called method references: L i s t < I n t e g e r > l i s t = . . . ; / / [ - 5 , 4 , - 3 , - 2 , 1 ] L i s t < I n t e g e r > n e w L i s t 3 = m a p p e r . a p p l y ( M a t h : : a b s , l i s t ) ; / / n e w L i s t 3 = [ 5 , 4 , 3 , 2 , 1 ] - The operator ::in Java is an instruction to build a lambda expression for the given method - So ::constructs a lambda expression with an appropriate number arguments for that method - E.g. in our example M a t h : : a b s constructs x - > M a t h . a b s ( x ) - The constructed lambda expression can then be used like any other lambda expression - This is a well known operation in the lambda-calculus called Î·-conversion (eta-conversion) - It says that, for any function , is equal to itselfğ‘“ Î»ğ‘¥ â†’ ğ‘“ ğ‘¥ ğ‘“ - This seems lovely and straightforward, however, we have to consider some special cases Computer Science / Software Engineering Notes Network - Here is an overview of the syntax and what it constructs: - In all cases except of Unknown Instance, it constructs a lambda expression with one argument - For unknown instance, the resulting lambda expression also expects the object reference as an argument - Letâ€™s look at an example for unknown instance - We will define a higher-order function that takes a function and a list of people, then applies that function to each person and prints the output of the function to the console: p r i v a t e s t a t i c < T > v o i d l i s t A l l ( F u n c t i o n < P e r s o n , T > f , L i s t < P e r s o n > p s ) { f o r ( P e r s o n p : p s ) { S y s t e m . o u t . p r i n t l n ( f . a p p l y ( p ) ) ; } } - This is how we could call this function using an unknown instance method reference: L i s t < P e r s o n > p e o p l e = L i s t . o f ( . . . ) ; / / a l i s t o f s o m e p e o p l e l i s t A l l ( P e r s o n : : g e t N a m e , p e o p l e ) ; l i s t A l l ( P e r s o n : : g e t H e i g h t , p e o p l e ) ; Recursion - Finally we will take a brief look at recursion - Anticlimax warning:they arenâ€™t very good - Unfortunately we cannot reference a variable in its own initialiser, like in this example: Computer Science / Software Engineering Notes Network c l a s s F a c t N o n E x a m p l e { s t a t i c F u n c t i o n < I n t e g e r , I n t e g e r > f = i - > ( i = = 0 ) ? 1 : i * f . a p p l y ( i - 1 ) ; i n t f a c t ( i n t n ) { r e t u r n f . a p p l y ( n ) ; } } - In order to make this work, we need to wrap the function inside another function which we will call Recursive: p u b l i c c l a s s F a c t E x a m p l e { p r i v a t e c l a s s R e c u r s i v e < I > { I f ; } p r i v a t e R e c u r s i v e < F u n c t i o n < I n t e g e r , I n t e g e r > > r e c = n e w R e c u r s i v e < > ( ) ; p u b l i c F a c t E x a m p l e ( ) { r e c . f = i - > ( i = = 0 ) ? 1 : i * r e c . f . a p p l y ( i - 1 ) ; } i n t f a c t ( i n t n ) { r e t u r n r e c . f . a p p l y ( n ) ; } } Computer Science / Software Engineering Notes Network Programming with Streams Functional programming and lists - We have list and arrays in Java but these are not like the lists in Haskell - In Haskell, lists are structural and immutable - Furthermore, the way we are used to traverse lists is not quite functional in style - Itâ€™s a process that is far too imperative - the traversals are done manually by the client by explicitly navigating the list External vs internal iteration - When we talk about iteration, there are two different approaches:external and internal iteration - Letâ€™s first look at an example of external iteration: I t e r a t o r i t = s h a p e s . g e t I t e r a t o r ( ) w h i l e ( i t . h a s N e x t ( ) ) { S h a p e s = i t . n e x t ( ) ; s . s e t C o l o r ( C o l o r . R E D ) } - This is an example of external iteration because you as a programmer control how the iteration happens - It is your responsibility that you select the next element, check whether there are any more elements left and so on - The enhanced for loop is just syntactic sugar for this - Now look at an example of internal iteration: s h a p e s . f o r E a c h ( s - > s . s e t C o l o r ( C o l o r . R E D ) ) ; - This time we do not control how the interaction happens - Instead we just pass a function which is executed on every element of the collection - In other words, you as a programmer just declaratively define what should happen with every element of the collection - The iteration itself happens in the background Streams in Java - As it turns out we have something in Java which is quite similar to the immutable lists in Haskell - These structures are called streams Computer Science / Software Engineering Notes Network - They support a number of useful stream operations which can be concatenated in a functional style - There are two types of stream operations - Intermediate stream operations - They are implemented as lazy operations, meaning that the stream values are calculated as they are required - They return another stream - They can be composed with other operations - Terminal stream operations - They are implemented as eager operations, meaning that all of the stream values are calculated - They consume the input stream and produce a side-effect or a return value - Ok this sounds good, but I still donâ€™t really get what a stream is. - No problem, letâ€™s look at a graphical example: - The stream in this graphic is the pipeline - As an input we get a big box of circles. They have different colours and sizes - We need to pour them into the pipe, and by doing that we produce a serial stream of circles - The first intermediate stream operation is â€œfilter redsâ€ - It will take the input stream - It will analyse every circle and throw away all red circles - It will produce an output stream that contains all the remaining balls - The next intermediate stream operation is â€œmake them triangle with same areaâ€ - It will inspect the area of each circle and produce a triangle with the same area and colour - The next intermediate stream operation is â€œfilter small trianglesâ€ - It will filter out all triangles that are smaller than some defined area - Now we have a terminal stream operation â€œsum up circumferencesâ€ Computer Science / Software Engineering Notes Network - It will take the input stream - For every element (triangle) it receives, it will calculate the circumference - It will sum up the circumferences and keep doing this until no further element (triangle) is received - It will not produce an output stream, it will produce a number - Now that we have seen a graphic example, letâ€™s switch back to Java - How can we produce a stream from an array or from a collection? S t r i n g [ ] a r r a y = . . . S e t < S t r i n g > h a s h = . . . S t r e a m < S t r i n g > a r r s t r = A r r a y s . s t r e a m ( a r r a y ) ; S t r e a m < S t r i n g > h a s h s t r = h a s h . s t r e a m ( ) ; - So Stream is a generic class, where you denote the type of the contents with the generic parameter - We can also produce a Stream like this: S t r e a m < I n t e g e r > s t r e a m = S t r e a m . o f ( 1 , 2 , 3 , 4 ) ; - Next we will look at stream operations in Java Common operations Map - Streams as Functors - First we will look at the stream operation map, which has the following signature i n t e r f a c e S t r e a m < T > { < R > S t r e a m < R > m a p ( F u n c t i o n < T , R > m a p p e r ) ; â€¦ } - It takes a function and applies the function to every element in the stream to produce a new transformed stream - The function takes an unstructured value and produces another unstructured value - Itâ€™s a lazy, intermediary operation - Here is an example S t r e a m . o f ( 1 , 2 , 3 , 4 ) . m a p ( n u m - > n u m * n u m ) . f o r E a c h ( S y s t e m . o u t : : p r i n t l n ) ; / / 1 4 9 1 6 - So whatâ€™s going on here? - We are producing a stream containing the numbers 1, 2, 3 and 4 - Then we are applying a function to each of the elements, where we multiply the element with itself. This will produce a new stream with modified elements. Computer Science / Software Engineering Notes Network - Then we are iterating over each of the elements and printing them to the console using a method reference. - This operation essentially makes the Stream a functor! - Why? Because a functor takes a structured value and an unstructured function and produces a new structured value flatMap - Streams as Monads - Now we will look at the operation flatMap, which has the following signature i n t e r f a c e S t r e a m < T > { < R > S t r e a m < R > f l a t M a p ( F u n c t i o n < T , S t r e a m < R > > m a p p e r ) ; } - It takes a function and applies the function to every element to produce the new transformed stream. - However, this time the function does not produce an unstructured value but produces a new stream with just that value, i.e. produces a structured value - However, as you can see flatMap returns a Stream and not a Stream with Streams inside. - Therefore, flatMap flattens all the streams the function produces and returns one single flat Stream. - Does this remind you of something? - Well this is exactly what the bind operation of a monad does, so Stream is also a monad! - In fact, Stream.of(...) is equivalent to â€œpureâ€ in Haskell because it converts an unstructured value into a structured value (into a Stream) - Here is the same example as above, but this time with flatMap: S t r e a m . o f ( 1 , 2 , 3 , 4 ) . f l a t M a p ( n u m - > S t r e a m . o f ( n u m * n u m ) ) . f o r E a c h ( S y s t e m . o u t : : p r i n t l n ) ; / / 1 4 9 1 6 More stream operations yay - We have seen map and flatMap, but there a whole load more stream operations, for example: Intermediate Operations filter Takes a predicate and returns a stream with elements that satisfy the predicate. Haskell Equivalent :filter peek Takes a consumer and returns a stream with the same elements but also feeds each element to the consumer. distinct Returns a stream with duplicate elements removed (it Computer Science / Software Engineering Notes Network uses .equals for checking equivalency). Haskell Equivalent :nub sorted Returns the stream sorted to their natural order (only for Streams of Comparable elements possible). Haskell Equivalent :sort iterate Takes a unary operator and a start element and produces an infinite stream by repeatedly applying the function. Haskell Equivalent :iterate Terminal Operations forEach Takes a consumer and feeds each element in the stream to it. Unlike peek it does not produce an output stream. toArray Simply converts the stream to an array and closes the stream. reduce Similar to a fold in Haskell. Takes a base element, and a binary operator and applies it element wise across the stream by accumulating the result. Note that no guarantee of order is given. max, min, count Examples of specific reduce operations Haskell Equivalent :maximum, minimum, length collect Converts the stream to a collection according to a specified Collector and closes the stream. - Letâ€™s look at a typical example of using Streams: L i s t < S t r i n g > j o b s = p s . s t r e a m ( ) / / S t r e a m < P e r s o n > . m a p ( x - > x . g e t J o b s ( ) ) / / S t r e a m < S e t < S t r i n g > > . f l a t M a p ( x - > x . s t r e a m ( ) ) / / S t r e a m < S t r i n g > . d i s t i n c t ( ) / / S t r e a m < S t r i n g > . c o l l e c t ( C o l l e c t o r s . t o L i s t ( ) ) ; / / L i s t < S t r i n g > - Suppose that we have an array of people and wish to list all the different jobs people have, but without repeating any jobs - Suppose also that we have a method getJobs() in Person which returns a Set of jobs of this person - Then we can get that list of jobs exactly like shown above. State of Streams - I have some bad news:We can only use every Stream once - Once we have operated on a Stream object it remembers that and will not allow any further operations - Thus Streams do have state:Either they are fresh or they already have been operated on. Computer Science / Software Engineering Notes Network - If you try to operate on a Stream twice, like in the following example, then a IllegalStateException will be thrown S t r e a m < I n t e g e r > s t r = S t r e a m . o f ( 1 0 , 2 , 3 3 , 4 5 ) ; S t r e a m < I n t e g e r > s t r F = s t r . f i l t e r ( x - > x < 3 0 ) ; S t r e a m < I n t e g e r > s t r M = s t r . m a p ( x - > x + 5 ) ; / / E x c e p t i o n t h r o w n h e r e Optional - A method of note in Stream is findFirst - It returns the first element of the stream but interestingly the return type is Optional<T> - An Optional<T> is a wrapper for an object of type T. It can either hold an actual value of T or it can hold nothing (i.e. be empty) - You can check via the method isPresent() if the Optional holds something - In addition, other interesting methods are - Optional<R> map(Function<T, R> f) - Optional<R> flatMap(Function<T, Optional<R> f) - Similarly, these make Optional into a Monad - Optional is the â€œMaybeâ€ we know from Haskell in Java. Parallel streams - The streams we have seen so far were all serial streams - However, there also exist parallel streams, which allow parallel processing - You can create such a stream by calling Collection.parallelStream() - However, be careful that the order of elements does not matter when you apply your stream operations - For streams where parallel processing is possible this can greatly improve efficiency - As an example, letâ€™s write a function that determines whether a number is perfect - A perfect number is equal to its sum of factors (not including itself) p u b l i c c l a s s P e r f e c t { s t a t i c b o o l e a n p e r f e c t ( i n t n ) { i n t f a c t o r S u m = I n t S t r e a m . r a n g e ( 1 , n ) . f i l t e r ( x - > ( n % x ) = = 0 ) . s u m ( ) ; r e t u r n f a c t o r S u m = = n ; } } p u b l i c s t a t i c v o i d m a i n ( S t r i n g [ ] a r g s ) { I n t S t r e a m . r a n g e ( 1 , 5 0 0 0 0 ) Computer Science / Software Engineering Notes Network . p a r a l l e l ( ) . f i l t e r ( P e r f e c t : : p e r f e c t ) . f o r E a c h ( i - > S y s t e m . o u t . p r i n t l n ( i + \" i s a p e r f e c t n u m b e r . \" ) ) ; } - The output is the following: 8 1 2 8 i s a p e r f e c t n u m b e r . 6 i s a p e r f e c t n u m b e r . 2 8 i s a p e r f e c t n u m b e r . 4 9 6 i s a p e r f e c t n u m b e r . - Because of the parallel stream, no order is guaranteed Computer Science / Software Engineering Notes Network Functional Programming in JavaScript - Weâ€™ll briefly look into functional programming in JS - First, letâ€™s compare OOP to FP Object-Orien ted Fun ctio n al Data and the operations upon it are tightly coupled Data is only loosely coupled to functions Objects hide their implementation of operations from other objects via their interfaces Functions hide their implementation, and the languageâ€™s abstractions speak to functions and the way they are combined or expressed The central model for abstraction is the data itself The central model for abstraction is the function, not the data structure The central activity is composing new objects and extending existing objects by adding new methods to them The central activity is writing new functions - In functional programming we describe what we want to achieve, not ho w we achieve it Functional vs Imperative Style - For example, we want to write a function that computes the sum of squares of all elements in an array - This is the imperative style, which we can find in methods in OOP: v a r s u m O f S q u a r e s = f u n c t i o n ( l i s t ) { v a r r e s u l t = 0 ; f o r ( v a r i = 0 ; i < l i s t . l e n g t h ; i + + ) { r e s u l t + = s q u a r e ( l i s t [ i ] ) ; }r e t u r n r e s u l t ; } ; c o n s o l e . l o g ( s u m O f S q u a r e s ( [ 2 , 3 , 5 ] ) ) ; / / p r i n t s 3 8 - As you can see, the focus of this code is how to actually compute the result - We have to iterate through the list and sum the squares of each element - It focuses on ho w we produce the square sum of the list - Now look at an example in functional style: v a r s u m O f S q u a r e s = p i p e ( m a p ( s q u a r e ) , r e d u c e ( a d d , 0 ) ) ; Computer Science / Software Engineering Notes Network c o n s o l e . l o g ( s u m O f S q u a r e s ( [ 2 , 3 , 5 ] ) ) ; / / p r i n t s 3 8 - As you can see the focus of this code is what we want to achieve, not how we do it - First it applies a function square to each element of the list - This is what map(square) does - Then it feeds the output of map into the reduce function - This is what pipe(..., â€¦) does - Then it adds all the elements of the list and produces a sum - This is what reduce (add, 0) does - It essentially works like a fold in Haskell - Note that all these functions are supplied by some third-party library, they are not core JS languages features - We will take a look at a third-party library (Rambda) a bit later Functional Features - What kind of functional features are available in JS? - First-class functions - We can pass around functions - Meaning that we can take a function as an argument or return a function - Lambdas/anonymous functions with closures - We can write lambda expressions - We have full support of closures - Stateless processing - Side-effect free function calls - Whatâ€™s not available in JS? - Tail recursion - Pattern matching - Lazy evaluation Functional Programming in JS with Rambda - From now on, we will look into an example of functional programming using the Rambda library - Our example will be a Task List application, which regularly fetches task data from the server. - The data looks like this: v a r d a t a = { r e s u l t : \" S U C C E S S \" , i n t e r f a c e V e r s i o n : \" 1 . 0 . 3 \" , r e q u e s t e d : \" 1 0 / 1 7 / 2 0 1 3 1 5 : 3 1 : 2 0 \" . l a s t U p d a t e d : \" 1 0 / 1 6 / 2 0 1 3 1 0 : 5 2 : 3 9 \" , t a s k s : [ Computer Science / Software Engineering Notes Network { i d : 1 0 4 , c o m p l e t e : f a l s e , p r i o r i t y : \" h i g h \" , d u e D a t e : \" 1 1 / 2 9 / 2 0 1 3 \" , m e m b e r : \" S c o t t \" , t i t l e : \" D o s o m e t h i n g \" , c r e a t e d : \" 9 / 2 2 / 2 0 1 3 \" } , { i d : 1 0 5 , c o m p l e t e : f a l s e , p r i o r i t y : \" m e d i u m \" , d u e D a t e : \" 1 1 / 2 2 / 2 0 1 3 \" , m e m b e r : \" L e n a \" , t i t l e : \" D o s o m e t h i n g e l s e \" , c r e a t e d : \" 9 / 2 2 / 2 0 1 3 \" } , { i d : 1 0 7 , c o m p l e t e : t r u e , p r i o r i t y : \" h i g h \" , d u e D a t e : \" 1 1 / 2 2 / 2 0 1 3 \" , m e m b e r : \" M i k e \" , t i t l e : \" F i x t h e f o o \" , c r e a t e d : \" 9 / 2 2 / 2 0 1 3 \" } , { i d : 1 0 8 , c o m p l e t e : f a l s e , p r i o r i t y : \" l o w \" , d u e D a t e : \" 1 1 / 1 5 / 2 0 1 3 \" , m e m b e r : \" P u n a m \" , t i t l e : \" A d j u s t t h e b a r \" , c r e a t e d : \" 9 / 2 5 / 2 0 1 3 \" } , { i d : 1 1 0 , c o m p l e t e : f a l s e , p r i o r i t y : \" m e d i u m \" , d u e D a t e : \" 1 1 / 1 5 / 2 0 1 3 \" , m e m b e r : \" S c o t t \" , t i t l e : \" R e n a m e e v e r y t h i n g \" , c r e a t e d : \" 1 0 / 2 / 2 0 1 3 \" } , { i d : 1 1 2 , c o m p l e t e : t r u e , p r i o r i t y : \" h i g h \" , d u e D a t e : \" 1 1 / 2 7 / 2 0 1 3 \" , m e m b e r : \" L e n a \" , t i t l e : \" A l t e r a l l q u u x e s \" , c r e a t e d : \" 1 0 / 5 / 2 0 1 3 \" } / / , . . . ] } - So as we can see, we receive a data object with a couple of properties. The most important one is the task property. It contains all tasks of members with some status information - We want to write a function that accepts a member parameter and - fetches the complete data from the server - then it chooses the tasks for that member that are not complete - then it filters out their ids, priorities, titles and due dates - then it sorts the data by due date - The fetch from the server will happen asynchronously, i.e. our application should not block when it waits for the data - Instead we will use promises that will eventually provide the data as soon it is available - We will attach a consumer to a promise via the â€œ.then(...)â€ function. The consumer function is called with the data as soon as the promise is fulfilled - We can attach multiple consumers which are called one after the other Iterative Approach - Letâ€™s look at the imperative approach: v a r g e t I n c o m p l e t e T a s k S u m m a r i e s F o r M e m b e r _ i m p e r a t i v e = f u n c t i o n ( m e m b e r N a m e ) { r e t u r n f e t c h D a t a ( ) Computer Science / Software Engineering Notes Network . t h e n ( f u n c t i o n ( d a t a ) { r e t u r n d a t a . t a s k s ; } ) . t h e n ( f u n c t i o n ( t a s k s ) { v a r r e s u l t s = [ ] ; f o r ( v a r i = 0 , l e n = t a s k s . l e n g t h ; i < l e n ; i + + ) { i f ( t a s k s [ i ] . m e m b e r = = m e m b e r N a m e ) { r e s u l t s . p u s h ( t a s k s [ i ] ) ; } }r e t u r n r e s u l t s ; } ) . t h e n ( f u n c t i o n ( t a s k s ) { v a r r e s u l t s = [ ] ; f o r ( v a r i = 0 , l e n = t a s k s . l e n g t h ; i < l e n ; i + + ) { i f ( ! t a s k s [ i ] . c o m p l e t e ) { r e s u l t s . p u s h ( t a s k s [ i ] ) ; } }r e t u r n r e s u l t s ; } ) . t h e n ( f u n c t i o n ( t a s k s ) { v a r r e s u l t s = [ ] , t a s k ; f o r ( v a r i = 0 , l e n = t a s k s . l e n g t h ; i < l e n ; i + + ) { t a s k = t a s k s [ i ] ; r e s u l t s . p u s h ( { i d : t a s k . i d , d u e D a t e : t a s k . d u e D a t e , t i t l e : t a s k . t i t l e , p r i o r i t y : t a s k . p r i o r i t y } ) }r e t u r n r e s u l t s ; } ) . t h e n ( f u n c t i o n ( t a s k s ) { t a s k s . s o r t ( f u n c t i o n ( f i r s t , s e c o n d ) { r e t u r n f i r s t . d u e D a t e - s e c o n d . d u e D a t e ; } ) ; r e t u r n t a s k s ; } ) ; } ; - We can also write this in an object-oriented approach - However, this will just shift the imperative code into methods of some class Computer Science / Software Engineering Notes Network - Therefore, the difference between the imperative code and object-oriented code is mostly just organisation - Back to our imperative code:Itâ€™s a bit of a lol - Itâ€™s very ugly and not very easy to understand/read - Be honest, when you first saw this, you probably thought WTF is going on?! - It would be so much nicer to write it in functional style - We just say what we want - We donâ€™t say ho w this is done - We could reduce the code a lot and make it much simpler, thus easier to understand - We will shift away the focus from â€œhow it is doneâ€ to â€œwhat we want to be doneâ€ - Letâ€™s convert this code step by step Get a property Get all tasks fro m data Imperative Functional . t h e n ( f u n c t i o n ( d a t a ) { r e t u r n d a t a . t a s k s ; } ) . t h e n ( g e t ( ' t a s k s ' ) ) - So what does get(...) do? - It returns a function that takes in an object and returns the specified property of the object - It is defined like this: v a r g e t = c u r r y ( f u n c t i o n ( p r o p , o b j ) { r e t u r n o b j [ p r o p ] ; } ) ; - Curry enables us to partially apply a function, i.e. only substitute some arguments of the function and return a new function containing the remaining arguments. - When we remove the curry function, it would look like this: v a r g e t = f u n c t i o n ( p r o p ) { r e t u r n f u n c t i o n ( o b j ) { r e t u r n o b j [ p r o p ] ; } ; } ; Filtering Filterin g tasks by member n ame - first versio n Computer Science / Software Engineering Notes Network Imperative Functional . t h e n ( f u n c t i o n ( t a s k s ) { v a r r e s u l t s = [ ] ; f o r ( v a r i = 0 , l e n = t a s k s . l e n g t h ; i < l e n ; i + + ) { i f ( t a s k s [ i ] . m e m b e r = = m e m b e r N a m e ) { r e s u l t s . p u s h ( t a s k s [ i ] ) ; } }r e t u r n r e s u l t s ; } ) . t h e n ( f i l t e r ( f u n c t i o n ( t a s k ) { r e t u r n t a s k . m e m b e r = = m e m b e r N a m e ; } ) ) - What does filter(...) do? - It takes a predicate and a list and checks for each element whether the predicate is true or false - It will produce a new list with all elements where the predicate was true - But where is the list argument in the implementation? - Well, it is a curried function, meaning that filter will return a function that takes in a list - Remember that the â€œthenâ€ block will pass the list of tasks to us - Look at how we manually defined the function that checks for the predicate - We can further improve this by writing a function which returns exactly such a function - Letâ€™s call it â€œpropEqâ€ since we want to check whether a property is equal to something - It will take a property and a value and return a function that checks equality like this: v a r p r o p E q = f u n c t i o n ( p r o p , v a l ) { r e t u r n f u n c t i o n ( o b j ) { r e t u r n o b j [ p r o p ] = = = v a l ; } ; } - This is still quite imperative - What we want to do is get some property and then check equality to some value - For â€œgetting some propertyâ€ we have the function â€œgetâ€, as we have seen earlier - For checking equality we can use the function â€œeqâ€ - If we pipe them together, we will get this slick definition: v a r p r o p E q = f u n c t i o n ( p r o p , v a l ) { r e t u r n p i p e ( g e t ( p r o p ) , e q ( v a l ) ) ; } - Looks pretty good so far, however it can still be improved - Note how we just take the arguments into â€œgetâ€ and â€œpropâ€ - We can use a function called use-over to make this even shorter: v a r p r o p E q = u s e ( p i p e ) . o v e r ( g e t , e q ) ; Computer Science / Software Engineering Notes Network - Now we have arrived at our final definition of propEq - Letâ€™s use it in our code: Filterin g tasks by member n ame - imp ro ved versio n Imperative Functional . t h e n ( f u n c t i o n ( t a s k s ) { v a r r e s u l t s = [ ] ; f o r ( v a r i = 0 ; i < t a s k s . l e n g t h ; i + + ) { i f ( t a s k s [ i ] . m e m b e r = = m e m b e r N a m e ) { r e s u l t s . p u s h ( t a s k s [ i ] ) ; } }r e t u r n r e s u l t s ; } ) . t h e n ( f i l t e r ( p r o p E q ( ' m e m b e r ' , m e m b e r N a m e ) ) ) Rejecting Rejectin g all tasks that are co mp leted Imperative Functional . t h e n ( f u n c t i o n ( t a s k s ) { v a r r e s u l t s = [ ] ; f o r ( v a r i = 0 ; i < t a s k s . l e n g t h ; i + + ) { i f ( ! t a s k s [ i ] . c o m p l e t e ) { r e s u l t s . p u s h ( t a s k s [ i ] ) ; } }r e t u r n r e s u l t s ; } ) . t h e n ( r e j e c t ( p r o p E q ( ' c o m p l e t e ' , t r u e ) ) ) - This is very similar to â€œfilterâ€, except that it keeps only those elements where the predicate is false - It is again a curried function that will return another function that takes in the list New objects from old On ly keep so me p ro p erties o f every task Imperative Functional . t h e n ( f u n c t i o n ( t a s k s ) { . t h e n ( m a p ( p i c k ( Computer Science / Software Engineering Notes Network v a r r e s u l t s = [ ] , t a s k ; f o r ( v a r i = 0 ; i < t a s k s . l e n g t h ; i + + ) { t a s k = t a s k s [ i ] ; r e s u l t s . p u s h ( { i d : t a s k . i d , d u e D a t e : t a s k . d u e D a t e , t i t l e : t a s k . t i t l e , p r i o r i t y : t a s k . p r i o r i t y } ) }r e t u r n r e s u l t s ; } ) [ ' i d ' , ' d u e D a t e ' , ' t i t l e ' , ' p r i o r i t y ' ] ) ) ) - We have seen â€œgetâ€ before to get a single property of an object. - Now â€œpickâ€ is very similar to â€œgetâ€, but it takes multiple properties out of an existing object and creates a new object - The â€œmapâ€ function will call some function, which is passed as an argument, on every element of a list Sorting So rtin g tasks by due date Imperative Functional . t h e n ( f u n c t i o n ( t a s k s ) { t a s k s . s o r t ( f u n c t i o n ( f i r s t , s e c o n d ) { r e t u r n f i r s t . d u e D a t e - s e c o n d . d u e D a t e ; } ) ; r e t u r n t a s k s ; } ) ; . t h e n ( s o r t B y ( g e t ( ' d u e D a t e ' ) ) ) ; - sortBy(...) will sort the list according to the key passed in - Again, we need get(...) to extract the due date from every element of the list Functional Approach - Letâ€™s summarise the functional approach we have seen so far v a r p r o p E q = u s e ( p i p e ) . o v e r ( g e t , e q ) ; / / T O D O : m o v e t o l i b r a r y ? v a r g e t I n c o m p l e t e T a s k S u m m a r i e s F o r M e m b e r F u n c t i o n a l = f u n c t i o n ( m e m b e r N a m e ) { r e t u r n f e t c h D a t a ( ) . t h e n ( g e t ( ' t a s k s ' ) ) / / G e t a P r o p e r t y . t h e n ( f i l t e r ( p r o p E q ( ' m e m b e r ' , m e m b e r N a m e ) ) ) / / F i l t e r i n g . t h e n ( r e j e c t ( p r o p E q ( ' c o m p l e t e ' , t r u e ) ) ) / / R e j e c t i n g Computer Science / Software Engineering Notes Network . t h e n ( m a p ( p i c k ( [ ' i d ' , ' d u e D a t e ' , ' t i t l e ' , ' p r i o r i t y ' ] ) ) ) / / N e w O b j . t h e n ( s o r t B y ( g e t ( ' d u e D a t e ' ) ) ) ; / / S o r t i n g } ; - Now compare this version with the imperative version we had before - This code is much more elegant and simpler than the imperative one - Alright thatâ€™s it, you have reached the end of the content - Next section will be a TL;DR ;) Computer Science / Software Engineering Notes Network TL;DR - Welcome to the TL;DR section! - Below is a summary of all the above notes. Use these for when you canâ€™t be asked to read the main notes for the millionth time! - However, remember that this is more like a reference guide;itâ€™s designed to jog your memory. - Please try to read the main notes at least once! Introduction to functional programming - Features o f Haskell: - C o n cise Pro grams - few keywords, support for scoping by indentation - Po werful Typ e System - types are inferred by the compiler where possible - List C o mp rehen sio n s - construct lists by selecting and filtering - Recursive Fun ctio n s - efficiently implemented, tail recursive - Higher-Order Fun ctio n s - powerful abstraction mechanism to reuse code - Effectful Fun ctio n s - allows for side effects such as I/O - Gen eric Fun ctio n s - polymorphism for reuse of code - Lazy Evaluatio n - avoids unnecessary computation, infinite data structures - Eq uatio n al Reaso n in g - pure functions have strong correctness properties - Evaluate exp ressio n s like this: - 5 + 6 - or - (+) 5 6 - Make a fun ctio n like this: - [function name] [parameters] = [function body] - Execute a fun ctio n like this: - [function name] [function parameters] - Standard list functions: - head returns first element from list - tail removes first element from list - length calculates length of a list - !! returns nth element of a list - take returns first n elements of a list - drop removes first n elements of a list - ++ appends two lists - sum calculates sum of elements in a list - product calculates product of elements in a list - reverse reverses a list - repeat creates infinite list of repeated elements Computer Science / Software Engineering Notes Network - Haskell is left associative, so - f a + b is f ( a ) + b and not f ( a + b ) - Useful GHCi commands: - :load name loads script name - :reload reload current script - :set editor name sets editor to name - :edit name edit script name - :edit edit current script - :type expr show type of expression - :? show all commands - :quit quit ghci - Name things in lower camelCase, likeThis. - In Haskell, whitespace matters, so your lines need to be at the same column. Types, Classes and Functions - To show that â€˜eâ€™has type â€˜tâ€™, write e : : t - Basic types: - Booleans - Characters - Strings - Numbers - Compound types: - Lists - Tuples - Functions - List values: - [ 1 , 2 , 3 ] is syntactic sugar for 1 : 2 : 3 : [ ] - Functions are automatically curried because Haskell is left associative - ( + ) is a function that takes two arguments - ( + ) 5 is a function that takes one argument - Po lymo rp hism:where type variables are used to represent any type - Example:h e a d : : [ a ] - > a - C lass:a set of properties a type can have/inherit - To show a type variable is in a class, do: - ( + ) : : ( N u m a ) = > a - > a - > a Computer Science / Software Engineering Notes Network - Types of classes: - Eq Supports == and /= - Ord Supports > and < - Show Supports converting to a string - Read Supports strings converting to this - Num Is either Int, Integer, Float or Double - Integral Is either Int, or Integer - Fractional Is either Float or Double - Hierarchy of classes: - Guards changes the behaviour based on predicates about the input: isThisOne x | x == 1 = True | otherwise = False - o t h e r w i s e is syntactic sugar for True. - w h e r e allows us to define constants within the scope of our function. - l e t and i n allows us to define constants within the scope of the following expression. - Pattern matchin g allows you to define a function in several parts depending on what is inputted: - n o t F a l s e = T r u e - n o t T r u e = F a l s e - Underscore is a wildcard: - i s T h i s T w o 2 = T r u e - i s T h i s T w o _ = F a l s e Computer Science / Software Engineering Notes Network - Structured p attern s:pattern matching with structures - f s t ( x , _ ) = x - List p attern s:using the cons operator as a pattern match - t a i l ( x : x s ) = x s - C o mp o site p attern s:using all of the above together - f e t c h _ [ ] = e r r o r â€œ E m p t y l i s t â€ - f e t c h 0 ( x : _ ) = x - f e t c h n ( _ : x s ) = f e t c h ( n - 1 ) x s - Lambda exp ressio n s:quick, temporary functions with no names - \\ x y - > x + y - Op erato r sectio n s:the prefix form of an infix operator - ( + 5 ) o r ( 5 + ) o r ( + ) List Comprehension and Recursion - List co mp rehen sio n :Haskellâ€™s version of set comprehension. - [ e x p r e s s i o n | c o n d i t i o n 1 , c o n d i t i o n 2 , c o n d i t i o n 3 . . . ] - The zip function allows you to stick two lists together: - z i p [ â€˜ a â€™ , â€˜ b â€™ , â€˜ c â€™ ] [ 1 , 2 , 3 ] - [ ( â€˜ a â€™ , 1 ) , ( â€˜ b â€™ , 2 ) , ( â€˜ c â€™ , 3 ) ] - Recursio n :a function calling itself within its own body - f a c n = n * f a c ( n - 1 ) - Glaser, Hartel and Garrattâ€™s 5 steps to better recursion: - Step 1:Define the Type - Step 2:Enumerate the Cases - Step 3:Define the simple (base) cases - Step 4:Define the other (inductive) cases - Step 5:Generalise and Simplify - Tail recursio n :like normal recursion, but an accumulator is kept. Can be easier to understand. Lazy evaluation stops it from computationally being any different to normal recursion. - f a c a c c n = f a c ( n * a c c ) ( n - 1 ) Higher Order Functions - Higher o rder fun ctio n :a function that either takes in a function or returns a function. Computer Science / Software Engineering Notes Network - Map :a function that applies a given function to all elements of an iterable data structure (like a list). - Filter:a function that returns a new list containing elements where a given predicate returns true on that input. - Fo ld:a function that collapses an iterable data structure into a single value. - D o llar o p erato r ($):takes a function and an argument and applies the function to the argument. Allows you to control associativity in Haskell. - Fun ctio n co mp o sitio n (.):composes two functions together, given that the output type of the first function is the same as the input type of the second function. Declaring Types - â€˜typ eâ€™:define synonyms for types type String = [ Char ] - â€˜dataâ€™:defines a new data type, which is instantiated by constructors data Pair = PairInt Int Int | PairString String String - â€˜n ewtyp eâ€™:like â€˜dataâ€™, but only has one constructor and only one type after the constructor newtype Pair = Pair ( Int , Int ) - â€˜classâ€™:defines a set of properties that a type can inherit class Functor f where fmap :: (a -> b) -> f a -> f b - â€˜in stan ceâ€™:defines an inheritance between a type and a class instance Functor Tree where fmap f ( Leaf v) = Leaf (f v) fmap f ( Node v l r) = Node (f v) (fmap f l) (fmap f r) - Red-black tree:a tree with the following rules: - The root is black - All the leaves are black - If a node is red, it has black children - Every path from any node to a leaf contains the same number of black nodes - They can be implemented using the â€˜dataâ€™keyword. - A bstract syn tax tree:a data structure that defines the structure of a grammar Computer Science / Software Engineering Notes Network - Fun cto r:a class that allows types to be mapped over - Law 1:f m a p i d = i d - Law 2:f m a p ( g . h ) = f m a p g . f m a p h - You can define direction in a tree by defining a data type Direction with constructors L and R. - You can define a trail in a tree by defining a type Trail to be a list of Directions. - To go back in the tree, make the Direction store the parent as well. Then, pair up trees with trails as you traverse. This is called a zipper type. - Three ways to represent graphs: - Indexed collections of nodes and edges - Mapping Ints to lists of Ints and calling it a graph - Structured data type with cyclic dependencies - Recursively defining a graph to be a node and itâ€™s adjacent â€˜graphâ€™s - Inductive approach with graph constructors - Nesting contexts, which are all individual parts of the graph Evaluation Order and Laziness - Eq uatio n al reaso n in g:following through how an equation simplifies step-by-step to prove a result - Pro o f by in ductio n :proving a base case P(0), then proving an inductive case for P(n + 1) assuming that P(n) holds - Redex:a part of an expression that you need to know the value of before you can compute the full expression. - B eta-reductio n :a process that converts a function call into an expression - C all-by-n ame:(also called outermost reduction with no reduction under lambda) function calls are processed without computing the value or even looking at the arguments. This allows Haskell to perform lazy evaluation, along with graph reduction. - C all-by-value:(also called innermost reduction with no reduction under lambda) arguments are processed before the function is called Computer Science / Software Engineering Notes Network - Grap h reductio n :storing the value of an expression in one place and having pointers to it when itâ€™s needed. One of the two methods that allows lazy evaluation. - Mo dularity:splitting up your Haskell code into â€˜dataâ€™and â€˜controlâ€™. Haskell allows this because itâ€™s lazy. - Strict ap p licatio n ($!):forces an evaluation on the right before applying the function Interpreters and Closures - Lambda calculus:a formal system to express functions - The three rules of lambda calculus: - variable x - function abstraction Î»x - > x - function application Î»x - > x y - B o un d variable:a variable within the same scope it was instantiated in - Free variable:a variable initialised outside the scope itâ€™s in - C lo sed exp ressio n :a lambda expression with no free variables - Variable cap ture:making a variable bound through beta reduction - A lp ha co n versio n :renaming variables so that we donâ€™t get variable capture - En viro n men t:a mapping from variables to expressions - Frame:an expression with an incomplete term that is currently being simplified - C o n tin uatio n :a stack of frames - C EK-machin e:an interpreter that combines environments, continuations and frames along with a set of rules to interpret lambda expressions. It stands for C ontrol, Environment, Kontinuation. - C lo sures:a pairing of functions to the environment of which it was called. Functional I/O and Monads - Pure fun ctio n :a function whose output solely depends on the input - Side-effect:relating to state-based behaviours that makes a function not pure - â€œ I O a â€ is a function that takes in a system state and returns a value of type a, along with the modified system state. - A ctio n :an expression of type I O a . - Three basic actions: - g e t C h a r : : I O C h a r - p u t C h a r : : C h a r - > I O ( ) - r e t u r n : : a - > I O a Computer Science / Software Engineering Notes Network - d o notation lets you sequentially perform actions - m a i n function in Haskell is of type I O ( ) - A p p licative:a class that takes in a wrapped function and a wrapped value, applies the wrapped function to the wrapped value and returns another wrapped value. - Law 1: p u r e i d < * > x = x - Law 2: p u r e ( g x ) = p u r e g < * > p u r e x - Law 3 (symmetry): x < * > p u r e y = p u r e ( \\ g - > g y ) < * > x - Law 4 (transitivity): x < * > ( y < * > z ) = ( p u r e ( . ) < * > x < * > y ) < * > z - Mo n ad:a class that takes a wrapped value and a function that returns a wrapped value, applies the function to the wrapped value and returns the result as another wrapped value. - Law 1:r e t u r n x > > = f = f x - Law 2:m x > > = r e t u r n = m x - Law 3:( m x > > = f ) > > = g = m x > > = ( \\ x - > ( f x > > = g ) ) Computer Science / Software Engineering Notes Network - map M is a function that works like bind, but instead it calls the function on all elements of a list and puts the results in a big wrapped list. - filterM is a function that applies a predicate that takes in a wrapped boolean and a set of values, and returns a new wrapped list of the values based on whether the predicate accepts them or not. Functional Programming in Java - Fun ctio n al in terface:an interface with only one method in it - Examples: - Runnable - Comparator - ActionListener - Lambda syntax can be used in place of anonymous inner classes - ( p a r a m e t e r s ) - > e x p r e s s i o n - Existing functional interfaces: - F u n c t i o n < T , R > R a p p l y ( T x ) - B i F u n c t i o n < T , U , R > R a p p l y ( T x , U y ) - P r e d i c a t e < T > b o o l e a n t e s t ( T x ) - C o n s u m e r < T > v o i d a c c e p t ( T x ) - S u p p l i e r < T > T g e t ( ) Computer Science / Software Engineering Notes Network - U n a r y O p e r a t o r < T > T a p p l y ( T x ) - B i n a r y O p e r a t o r < T > T a p p l y ( T x , T y ) - In anonymous inner classes (AICs), t h i s refers to anonymous class, whereas with lambda it does not - Outside variables referenced in AICs and lambdas are â€œcopiesâ€ and need to be effectively final or final - t h i s is final, but the members donâ€™t have to be, so you can use t h i s . x and x can be mutable - If you wrap any variables into a data structure and initialise it as final, then you can make that variable mutable. - x - > M a t h . a b s ( x ) is the same as M a t h : : a b s - Overview of the syntax: - C l a s s N a m e : : s t a t i c M e t h o d ( a r g s ) - > C l a s s . s t a t i c M e t h o d ( a r g s ) - o b j : : m e t h o d ( a r g s ) - > o b j . m e t h o d ( a r g s ) - s u p e r : : m e t h o d ( a r g s ) - > s u p e r . m e t h o d ( a r g s ) - C l a s s N a m e : : n e w ( a r g s ) - > n e w C l a s s ( a r g s ) - C l a s s N a m e : : m e t h o d ( o b j , a r g s ) - > o b j . m e t h o d ( a r g s ) - T y p e N a m e [ ] : : n e w n - > n e w T y p e N a m e [ n ] - Normally recursion is impossible because you canâ€™t reference a variable in its own initialiser. - To do recursion, wrap your function inside another function. Programming with Streams - Extern al iteratio n :you, the programmer, explicitly iterating through each element of the list - In tern al iteratio n :defining what should happen on each element without actually going to every single element - Streams:structures that allow you to sequence stream operations on a piece of data in a functional style - In termediate stream o p eratio n s:performs an action and returns another stream. Can be composed with other stream operations - f i l t e r - p e e k - d i s t i n c t - s o r t e d - i t e r a t e - Termin al stream o p eratio n s:consumes the stream and does not return another stream. Usually performed last. Produces either a side-effect or a return value. - f o r E a c h - t o A r r a y - r e d u c e Computer Science / Software Engineering Notes Network - m a x - m i n - c o u n t - c o l l e c t - m a p is Javaâ€™s equivalent of f m a p - f l a t M a p is Javaâ€™s equivalent of bind (> > = ) - O p t i o n a l < T > is Javaâ€™s equivalent of M a y b e - Streams can only be used once, therefore Java streams have a state. - Parallel stream:a stream that supports parallel processing. Can improve efficiency if parallel processing is possible. Can be created with the C o l l e c t i o n . p a r a l l e l S t r e a m ( ) method. Functional programming in JavaScript - In functional programming, we describe what we want to achieve, not how we achieve it. Fun ctio n al features in JS Fun ctio n al features n o t in JS First-class functions Lambdas/anonymous functions with closures Stateless processing Side-effect free function calls Tail recursion Pattern matching Lazy evaluation Functional programming in JS with Rambda - Rambda:a functional programming library for JavaScript â€œRambdaâ€ fun ctio n What do es it do c u r r y ( f u n c t i o n ) Returns a curried version of f u n c t i o n , so you can partially apply it and get new functions. This is used with all the below Rambda functions. g e t ( p r o p , o b j ) Returns the property p r o p of the object o b j . f i l t e r ( p r e d i c a t e , l i s t ) Takes a predicate and a list and checks for Computer Science / Software Engineering Notes Network each element whether the predicate is true or false. It creates a new list with all the elements where the predicate is true. p i p e ( f n 1 , f n 2 , . . . , f n n ) Performs function composition from left to right, starting with f n 1 and ending with f n n . e q ( o b j 1 , o b j 2 ) Returns true if o b j 1 and o b j 2 are equal, and returns false if not. u s e ( f u n c ) . o v e r ( t f 1 , t f 2 , . . . , t f n ) Returns a function which accepts N parameters, feeds them to their respective transformers, and then calls f u n c using the results of all these as arguments. r e j e c t ( p r e d i c a t e , l i s t ) Like filter, but does the opposite;it keeps elements where the predicate is false and rejects ones where itâ€™s true. m a p ( f u n c t i o n , a r r a y / o b j e c t ) Maps over the array/object, applying the map function to all elements p i c k ( p r o p s , o b j ) Similar to get, but p r o p s is an array selecting multiple properties to take out. It returns a new object. s o r t B y ( f u n c t i o n , a r r a y ) Returns a copy of a r r a y sorted by f u n c t i o n . Recommended Reading (QA 76.55A1 PEY) The Implementation of Functional Programming Languages, Simon L. Peyton Jones;Chapter 2:Gives a clear definition of lambda calculus as well as the lambda calculus techniques necessary for the lambda calculus coursework (assuming it still exists).","libVersion":"0.3.2","langs":""}