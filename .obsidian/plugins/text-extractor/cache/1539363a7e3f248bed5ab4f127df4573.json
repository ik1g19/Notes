{"path":"Git Ignore/Matthew Barnes Notes/Automated Code Generation Notes.pdf","text":"Computer Science / Software Engineering Notes Network Automated Code Generation Matthew Barnes Introduction 3 History of Software Reuse 3 Our solution 5 Concepts in Code Generation 6 Code Generator Structure 7 Code Generation Approaches 8 Transformations 9 Domain Modelling 11 C Macros 14 Macros 14 Macros in Code Generation 14 Macro Operators 15 Computer Science / Software Engineering Notes Network Coding Idioms with Macros 15 Macro Hygiene 16 Why Syntax Macros Suck 16 Hygienic Macros 18 C++ Templates 21 Templates in C++ 21 Template Parameters 23 Templates are Syntactic Macros 24 Why C++ Templates Suck 25 Templates Specialisation in C++ 25 Template Metaprogramming 30 IF<> 30 WHILE<> 31 Loop Unrolling 32 ADTs 35 Expression Templates 37 Aspect Oriented Programming with AspectJ 38 Aspect Oriented Programming Concepts 38 Introduction to AspectJ 41 Call vs Execution 43 State-Based Pointcuts 43 Class JoinPoint 45 Advice Placement 45 CFlow 46 Inter-Type Declarations 47 Why AspectJ Sucks 48 Quote-Based Metaprogramming 48 Entry Points 50 Using ` and # 51 Using infer 52 Unquote Splice 52 Convenience Methods 53 Why Meta-AspectJ Sucks 55 Transformative Code Generation 55 Let’s Get Meta! 56 Listeners 60 Software Sec Example 64 Visitors 68 Binary Tree Example 69 Other Features 74 Alternative Labels 74 Rule Element Labels 74 Computer Science / Software Engineering Notes Network Actions 75 Node Values (Attributes) 75 TokenStreamRewriter 76 Why ANTLR Sucks 78 Introduction - Hello! Welcome to the Automated Code Generation Notes. - If you find any mistakes or have any questions, please feel free to leave a comment or make a suggestion. - Don’t feel bad about bothering me;I really am quite happy to see what you have to say / want to change! - With that out of the way, let’s jump straight in! History of Software Reuse - Throughout history, programmers have re-used software. - This is based on: - A bstractio n (providing an intuitive API / interface with no mess) - En cap sulatio n (splitting everything up into easy-to-digest modules) - There’s loads of ways to use reusable software: - Function libraries (SDL, Lodash, NumPy, ...) - Components (Java Beans, React / Vue libraries, ...) - Dedicated “processors” (SQL processors) - Frameworks (Eclipse, Ruby on Rails, Angular, ...) - Design patterns (Singleton, Delegation, ...) - Middleware systems (Android libraries form middleware between Linux kernel and applications) - Only problem is... - ... they suck. - Why do they suck? - Libraries and components suck because: - Encapsulation can prevent optimisation (running two methods from a library may be less efficient than running code that conjoins the two operations) - Static error checking is limited - Combinatorial explosion (library scaling could go too far;‘bloat’) - Frameworks suck because: - APIs too large / difficult (like library scaling, plus there’s too much boilerplate code) - Framework evolution (interaction between framework and completion code needs constant updating) - Middleware sucks because: - APIs too large / difficult - Runtime overheads (enforcement of middleware protocol at runtime) Computer Science / Software Engineering Notes Network Example: Why Libraries Suck - Let’s give a little example. - We have a library for matrix arithmetic, and we want to do this operation: - C = ( A + B ) T - Using this library, we could implement it this way: - a d d ( A , B , M ) - t r a n s p o s e ( M , C ) - Substituting in the function bodies, our code would really be: - f o r i i n A . r o w s - f o r j i n A . c o l s - M [ i , j ] = A [ i , j ] + B [ i , j ] - f o r i i n M . r o w s - f o r j i n M . c o l s - C [ j , i ] = M [ i , j ] - That looks fine, right? - Hmm... it could be better. - We could optimise this into one loop: - f o r i i n A . r o w s - f o r j i n A . c o l s - C [ j , i ] = A [ i , j ] + B [ i , j ] - ... but because our library is split into different operations, we can’t do it that way. Automated Code Generation: “Everything you love sucks.” - What’s the cause of this sucky-ness? - Geek Ego ism:Insufficient / wrong abstractions - Written for the developers, not for the actual end users - Embo dimen t:Functionality == components - Concepts don’t exactly map one-to-one with components - Concepts like: - Distribution (using across networks) - Security - Persistence (persist data for our system) - Lin guistic p o verty:Host language restrictions - Cannot extend syntax to reflect domain notations - For example there is no ‘transpose’operator in Java - Other syntax include: - Mathematical operators - Regular expression - Parser combinators - SQL query syntax Computer Science / Software Engineering Notes Network - Alright, we get it. - Everything we’ve known and used is crap, and we should feel bad. - So, what? We go Terry A. Davis and write our own compilers from scratch? - We don’t have to go that extreme... (By the way, I was joking about everything sucking. You can continue to use libraries and such if you wish.) Our solution - We use code generation! - With code generation, we can: - use better abstractions by considering programs as data objects - use more powerful mechanisms with meta-programming - use better languages that capture domain-specific abstractions - We make computers do the programming! Um... that’s not quite what I meant. - To put it a better way, we can call this “automation of programming”. - We kind of do this already, especially in the C / C++ language. - If you didn’t know, an array in C / C++ is just a pointer to the start of the array. - So when you do: - a [ i ] [ j ] - You’re actually doing: - * ( * ( a + i ) + j ) - In addition, p rep ro cesso r directives are kind of like code generation, too. - # d e f i n e M A X ( x , y ) x > y ? x : y - . . . - i n t a = 1 0 , b = 2 0 ; - M A X ( a , b ) /* This will be changed to a > b ? a : b after compilation */ - There’s even more ways we do code generation, like temp lates, which are “macros for classes”, and asp ects, which are code fragments “woven” into base code. - Programming can also be automated using dedicated separate tools. - There’s ones like: Computer Science / Software Engineering Notes Network - lex / yacc scanner / parser generators - Input:grammar rules with embedded action code - Output:code comprising of: - table data structures - driver code (boilerplate) - action code spliced in at correct locations - Generator:implementation of LR-parsing theory - JavaC C scanner / parser generator - Input:grammar rules with embedded action code - Output:code comprising of: - functions for recursive descent parsing rules - driver code (boilerplate) - action code spliced in at correct locations - Generator:implementation of LL-parsing theory - C A SE to o ls (e.g. Simulink Coder) - Input:system configuration represented in GUI - Output:code skeleton - Generator:traverses system structure, emits text Concepts in Code Generation - Code generation can be roughly defined as: - “Automatic derivation of source code in a conventional language from an input model.” - It’s like compilation, except there’s a bigger semantic gap. - In compilers, you go from source code → AST. - In code generators, you can interleave and/or repeat steps (search & control). - In addition, code generators are more knowledge-intensive. - Without code generators, development processes go like this: - However, with code generators, development processes go like this: Computer Science / Software Engineering Notes Network - Code generators reduce the conceptual gap, as well as formalises and internalises domain and design knowledge. - Just because it’s called code generation doesn’t mean it has to generate code. - It can generate a load of other things too: - Documentation (man pages) - Installation and control scripts - Test data, test data generators, and simulations - Proofs of safety, effectiveness, correctness - Trace information between model and code (so when something goes wrong in the code, you know exactly where the problem lies in the model, too) - In case you didn’t get enough from the intro, here’s why we should use code generation: - Increased p ro ductivity - Fast turn-around from high-level spec to system implementation - Increased reliability - No manual coding errors - Increased p o rtability - Re-generate for new platform - Increased level of in ten tio n ality - Algorithms represented in domain-specific concepts (instead of convoluted low-level code) Code Generator Structure - So what does a code generator actually look like? - Like this: Computer Science / Software Engineering Notes Network - Oof... that’s a lot to take in at once. - Let’s try to make sense of this: - We have a mo del, which is text, written in a language with a given grammar. - We can parse its A ST, as well as extract information into a tran sfo rmatio n database. - We can perform some basic tran sfo rmatio n s that are baked into the code generator itself, as well as some additio n al tran sfo rmatio n s extracted from the model. - We can reflect and reason upon our transformations using meta-information from the grannar. - At the end, we can generate an AST of the generated code, and unparse it into generated source code, using some given grammar. - If that made no sense, don’t worry;hopefully it’ll make more sense later on in the module. - For now, just think this: - Feed generator model - Generator parses AST from model - Generator uses engine, transformation database, and meta-information to perform transformations - Generator unparses AST into output source code Code Generation Approaches - There are different kinds of code generators. - These categories are called p aradigms. - Like how programming languages are within a spectrum of paradigms (a language can have OOP and functional elements), code generators are within a spectrum of paradigms too. - Here they are, given by main operation or data structure: Computer Science / Software Engineering Notes Network Generative or code-based - Assemble code from fragments - Macros, C++ templates, aspects - Template engines (JET, Velocity, ...) Transformative or model-based - Refine model into code - MDA / MBSE / ... D eductive or proof-based - Logically deduce code from specification - Amphion, KIDS / PlanWare / SpecWare, ... Transformations - There are different “software transformations” that a generator can make. - Ho rizo n tal transformations: - Evolution:evolve specification - Refactoring:evolve architecture - Vertical transformations: - Refinement:implement / refine to code - When we say the words “horizontal” and “vertical”, that insinuates we have dimensions to “transform” around. - The vertical dimension is like our level of abstraction. - If we’re really high, we’re talking about our domain-specific language;really high level stuff. - If we’re really low, we’re talking about system implementation;low level stuff. - The horizontal dimension is like our semantics. - As we move around this dimension (take horizontal transformations), we are changing things, refactoring, optimising etc. and generally changing the semantics of our model. Computer Science / Software Engineering Notes Network - In terms of transformations, there are two kinds of generators: Compositional - Compositional generators only apply vertical transformations. - It was introduced by B atory, and is typical for CA SE tools; models built with GUIs. - They preserve structure, because semantics do not change. This way, generated code can be traced back to the initial model. Holistic - Holistic generators apply both vertical and horizontal transformations. - In other words, “whole system” transformations, capable of: - Optimisation - Refactoring - Weaving - However, some transformations are a combination of both vertical and horizontal transformations, called oblique transformations. - These transformations can bridge bigger semantic gaps. Example: Oblique Transformations - If you want an example of an oblique transformation, think of the matrix add + transpose example we had in the introduction, but instead, our “model” looks like this: - M = A + B - C = M T Computer Science / Software Engineering Notes Network - We could take a horizontal step to optimise the model: - C = ( A + B ) T - Then, a vertical step to implement the model: - f o r i i n A . r o w s - f o r j i n A . c o l s - C [ j , i ] = A [ i , j ] + B [ i , j ] - This can all be done in a single oblique transformation! I said Holistic, not Heuristic! Domain Modelling - We need a way of expressing our domain of interest. - Therefore, we need to model it. - For example, if we’re creating physics simulation software, we need to model objects, how they behave, physics rules etc. - When we do do main mo dellin g, we need to establish and define: - Vocabulary (keywords, GUI widgets etc.) - Concepts and roles - Features / Options - We need to define common and variable properties of the systems: - Semantics - Dependencies - we need to define common architectures - The starting point of code generation is to get your domain model right. - As they say: “Good domains (for code generation) have good domain models!” - Julian Rathke - Domain modelling schlomain modelling... this stuff is easy. - Right? - Wrong! - It’s quite hard to model a domain, because: - it requires a lot of domain experience - experts think about things too abstractly for code generation Computer Science / Software Engineering Notes Network - What we mean by “abstract” is, for example, domain concepts that are all maths. - As a programmer, you know that code is not maths. Maths is way higher level. - In some domains, it’s so high level that it’s a real challenge porting that to code. - In other words, it’s to o declarative. Domain experts - Domain modelling requires a fo rmal mo dellin g lan guage. - Which one? There’s: - UML - Classes → concepts - Relations → roles - OCL to restrict combinations - Tool support - Graphical editors (e.g. CRAFT, used for ontologies) - Transformation tools - Others such as description logics - Gen erative do main mo dellin g must cover problem space and solution space. - In other words, it transforms: - from the problem space (our high-level domain model) - to the solution space (our low-level implementation) - Here’s the illustration from the slides - However, there’s not always a clear-cut separation from problem and solution space. Computer Science / Software Engineering Notes Network - Therefore we use solution concepts. - So lutio n co n cep ts are code fragments and structures in the domain model. - They can also provide relevant variables and types for given parts of the model. - They can be difficult to express, as they need to have an order and dependencies. The red circled bits are solution concepts and variables + types inside the UML model. - They may need to use specialised notation (which may not be available in languages such as UML). - Feature models are also quite hard to express as well. - Did you really think you’d be writing generators from scratch? - There are gen erato r framewo rks that provide dedicated tools to build generators. - They provide tools for: - Meta-modelling (MetaEdit+, GME, ...) - Meta-programming (C++ templates, ...) - Transformation and search (Stratego, ...) - They are used to build themselves (bootstrapping) - Requires metamodel of the system (UML defined within metamodel) - Supports customisation - Modify specification language - Retarget implementation language - Extend transformation base - This is all super high-level. - We won’t cover domain modelling in such high depth in this module. - We’ll focus more on transformation techniques instead. Computer Science / Software Engineering Notes Network C Macros Macros - I’m not going to teach C in these notes. - If you don’t know C, read an online tutorial or something. - However, I will talk about macros. - When a C program is compiled, there is a pre-processing step that performs text-substitution based on predefined preprocessor directives/rules, known as macro s. - There are a number of different directives, like # i n c l u d e and # d e f i n e . - C macros are like a “bare-bones” code generator. - Macros associate names with code fragments: # d e f i n e P I 3 . 1 4 1 5 9 - Macros can have parameters: # d e f i n e A D D ( x , y ) x + y - Macros can be layered (macros can use other macros): # d e f i n e A R E A ( r ) P I * r - However, just like how Java arrays are not type-safe, C macros are not recursive! - These are often used in: - Scientific computation - Embedded programming Macros in C ode Generation - So how are C macros like code generation? - The preprocessor is like the generator engine. - The macro definitions are like the rewrite rules. - Macros look and work like functions, but there’s one huge difference... - C macro arguments can be arbitrary code fragments. - They can even be types! Macro Usage # d e f i n e S W A P ( T , x , y ) { T t = x ; x = y ; y = t ; } i n t l o = 1 0 ; i n t h i = 2 0 ; S W A P ( i n t , l o , h i ) ; → { i n t t = l o ; l o = h i ; h i = t ; } Computer Science / Software Engineering Notes Network - ... or even proper statements! Macro Usage # d e f i n e E X E C U T E ( s ) s ; i n t a = 1 , b = 2 ; c ; E X E C U T E ( c = a + b ) ; → c = a + b ; Macro Operators - Macros have some special operators you might not be aware of. - Here’s three of them: - Strin gizin g o p erato r (#) - Converts a token to a string literal. Macro Usage # d e f i n e V A R _ N A M E ( x ) # x c h a r * v a r N a m e = V A R _ N A M E ( f o o ) ; → c h a r * v a r N a m e = “ f o o ” ; - C harizin g o p erato r (#@) - Converts a token to a character literal. Macro Usage # d e f i n e A S _ C H A R ( x ) # @ x c h a r m y C h a r = A S _ C H A R ( f ) ; → c h a r m y C h a r = ‘ f ’ ; - To ken -p astin g o p erato r (##) - Also called the merging or combining operator. - It lets you combine tokens together by unwrapping their values and sticking them together. - If the given token is not a parameter, it just uses the token name. Macro Usage # d e f i n e M A K E _ V A R ( T , i d , v a l ) T v a r # # i d = v a l # d e f i n e M A K E _ V A R _ N A M E ( T , n a m e , i d , v a l ) T n a m e # # i d = v a l M A K E _ V A R ( c h a r , 5 6 , 1 0 ) ; → c h a r v a r 5 6 = 1 0 ; M A K E _ V A R ( i n t , j o j o , 3 , 8 ) ; → i n t j o j o 3 = 8 ; C oding Idioms with Macros - Macros can also be used to hide coding idioms in syntax. - You need to find out what can be generalised, and replace them with macro parameters. - A good example are functional programming concepts, like map or filter (or, if you’re familiar with .NET, Select and Where). - Here’s a ‘foreach’macro I wrote that works with arrays: Macro Usage Computer Science / Software Engineering Notes Network # d e f i n e F O R E A C H ( a r r , l e n , i , s t ) { \\ i n t i = 0 ; \\ f o r ( i = 0 ; i < l e n ; i + + ) { \\ s t ; \\ } \\ } i n t a r r [ 1 0 ] = { . . . } ; / * S e t s a l l e l e m e n t s t o 0 * / F O R E A C H ( a r r , 1 0 , i , a r r [ i ] = 0 ) ; → { i n t i = 0 ; f o r ( i = 0 ; i < 1 0 ; i + + ) { a r r [ i ] = a r r [ i ] + 1 ; } } - Using the FOREACH macro as a base, you could implement other macros, such as MAP. - So, C macros are cool. - It allows you to abstract lower-level implementation by text substitution. - You can even make a simple DSL (domain-specific language) with it. - But, there’s one small problem... - ... it sucks. - We’ll explain why it sucks in the next section. Macro Hygiene - Macros that work with text substitution are called syn tax macro s (or lexical macro s). Why Syntax Macros Suck - There’s a couple of problems with them: Pro blem Examp le + So lutio n Operator priorities can interfere with complex macro arguments and bodies Example # d e f i n e D E G T O R A D ( x ) x * P I / 1 8 0 D E G T O R A D ( a - b ) → a - b * 3 . 1 4 1 5 / 1 8 0 It’s going to do a - ( b * 3 . 1 4 1 5 / 1 8 0 ) When really we wanted ( a - b ) * 3 . 1 4 1 5 / 1 8 0 Solution B racket the macro arguments,and add outer brackets,so calls like 1 / D E G T O R A D ( a ) will work as well: # d e f i n e D E G T O R A D ( x ) ( ( x ) * P I / 1 8 0 ) Computer Science / Software Engineering Notes Network Macro body can interfere with surrounding syntax Example # d e f i n e S W A P ( x , y ) t = x ; x = y ; y = t i f ( a > b ) S W A P ( a , b ) ; → i f ( a > b ) t = a ; a = b ; b = t ; The part that says t = x ; ( t = a ; in the expanded code) terminates the if statement, so the rest of the macro, namely x = y ; y = t ; ( a = b ; b = t ; in the expanded code) will not be included in the if clause. Solution Proper “packaging” of the macro body: # d e f i n e S W A P ( x , y ) { t = x ; x = y ; y = t } Side effects in macro arguments can be duplicated Example # d e f i n e M I N ( x , y ) ( ( ( x ) < ( y ) ) ? ( x ) : ( y ) ) i n t a = 1 , b = 2 ; i n t x = M I N ( + + a , + + b ) → i n t x = ( ( ( + + a ) < ( + + b ) ) ? ( + + a ) : ( + + b ) ) In the macro expansion, ++a or ++b are executed twice (depending on what is returned), leading to unwanted values: a = = 3 , b = = 3 , x = = 3 Solution Use local temporary variables # d e f i n e M I N ( x , y ) \\ ( { t y p e o f ( x ) _ x = ( x ) ; \\ t y p e o f ( y ) _ y = ( y ) ; \\ _ x < _ y ? _ x : _ y ; } ) However,this is not A NSI-C ;in other words,this does not conform to the C standard set by A NSI and ISO. Variable declarations in body can capture arguments Example # d e f i n e S W A P ( T , x , y ) { T t = x ; x = y ; y = t ; } i n t t = 0 , s = 1 ; S W A P ( i n t , t , s ) ; Computer Science / Software Engineering Notes Network → { i n t t = t ; t = s ; s = t ; } ; The code: i n t t = t ; t = s ; s = t ; does not swap t and s, because the instance of t outside the block is not changed. Solution Obfuscate local variables # d e f i n e S W A P ( T , x , y ) { T _ t _ S W A P = x ; x = y ; y = _ t _ S W A P ; } This isn’t foolproof;it just reduces the chance of this problem arising. - Automated Code Generation:where everything sucks;even code generation. - To prevent these problems, we need to clean our macros. - In other words, we need to ensure they are hygienic. Hygienic Macros - What does it mean for a macro to be hygien ic? - There are three categories of hygiene: - Syntactic hygiene - Guarantees structuralintegrity of expanded code. - Basically, when macros are expanded, the whole code is still valid syntax. - This can be achieved by using trees (ASTs) instead of text. - Variable hygiene - Guarantees referential integrity of expanded code. - Basically, all the local variables in the macro do not affect the variables outside the macro (see the “Variable declarations in body can capture arguments” example above). - This can be achieved by controlled renaming. - Type hygiene - Guarantees type integrity of expanded code. - Basically, the typing of the whole code still holds up after the macro has been expanded. - This is difficult to achieve. Computer Science / Software Engineering Notes Network Wash your macros before you use them. - To guarantee structural integrity, we use syntax trees. - All code can be tokenized into abstract syntax trees (ASTs). - Instead of replacing text, macros should insert trees. - To do this, macros must be syntactically well-structured. - It’s no good putting half-written code into macros. - If macro bodies are not well-structured, then we can’t create ASTs of them. - To check if macro bodies are well-structured and create ASTs of them, our macro processor needs to be language-aware;they need to know what makes good code. - This means the macro processor needs to have tight integration with the compiler, making this type of macro less general. - Despite this, macros don’t have to be a compilation unit. - What we mean by this is that macros don’t have to be ‘terminating’;it can trail off with a non-terminal, as long as the macro code is “finished off” when it’s used. - To guarantee referential integrity, we use renaming. - Referen tial in tegrity:names refer to the “right” objects. Computer Science / Software Engineering Notes Network - You could obfuscate the local variables in a macro body, but that’s not a true solution. - A better solution would be to bind renaming of introduced names. - What do I mean by that? I’ll show you... Example: Matt’s Teach Yourself Scheme in 3 Minutes - Let’s create a macro in Scheme. - Why? - Because they make one in the slides, and I’m scared that a Scheme question might come up in the exam (probably not, but covering this puts my mind at ease). - If you wanna check Scheme out, I suggest you pick up a Scheme compiler (I used racket) and check out this site. ( define-syntax push ( syntax-rules () (( push v s) ( set! s ( cons v s))))) - That’s a lot of brackets. So what does this do? - In layman’s terms, this defines a p u s h macro that takes in a value and a list, and appends the value to the list. - Here’s how it works in more detail: - The d e f i n e - s y n t a x keyword creates a macro called p u s h . - The s y n t a x - r u l e s block means this macro uses pattern-matching to find instances of where this macro is used, before replacing it with the macro body. - The ( p u s h v s ) part means that if there is a call to p u s h somewhere in our code, like: - ( p u s h “ i t e m ” m y _ l i s t ) - ... we should replace it with this s e t ! call, where “ i t e m ” is the parameter v and m y _ l i s t is the parameter s . - The s e t ! call sets a value to a variable, and c o n s is like the list constructor from Haskell. - If you want to know more about this Scheme syntax, I suggest checking out the site linked above. It’s quite short. - Alright, so what? We have a macro in Scheme, now what? - If we tried to define a list called c o n s and tried to use that as an argument to our macro, we’d end up getting two c o n s ’. ( define cons ( list 1 2 3 )) ; defines a list called 'cons' with (1 2 3) in it ( push 4 cons) → (set! cons (cons 4 cons)) - Oof! You see that? “cons 4 cons”. That’s not good. - To guarantee referential integrity, we make these terms refer to the right objects. - For example, when we want to use the ‘cons’keyword to refer to our newly created list, it should point to the list, and not to the keyword for list construction. - One way we can do this is to timestamp names with nesting levels: ( define-syntax push Computer Science / Software Engineering Notes Network ( syntax-rules () (( push v s) ( set! s ( cons:0 v s))))) ( define cons:1 ( list 1 2 3 )) ; defines a list called 'cons:1' with (1 2 3) in it ( push 4 cons:1 ) → (set! cons:1 ( cons:0 4 cons:1 )) - Boom! Our macro is now super cleanly. C++ Templates Templates in C++ - I love stacks. - Stacks have given us so many things:stacks of pancakes, Tower of Hanoi, Pringles, etc. - In fact, let’s implement a stack right now. You with me? Let’s go! c l a s s S t a c k { s t d : : v e c t o r < i n t > r e p ; p u b l i c : v o i d p u s h ( c o n s t i n t & t ) ; i n t p o p ( ) ; b o o l i s _ e m p t y ( ) ; } ; - Oh... a stack of i n t s. I wanted a stack of pancakes. - But what if I also wanted a stack of pringles, and a stack of c h a r s, too? - We can use C++ templates! - C ++ temp lates are parameterized declarations. - This means that, by using C++ templates, you can add parameters to declarations, so when you declare stuff, you can add arguments to change what you’re declaring exactly. - Let’s add a C++ template to our stack example: t e m p l a t e < c l a s s T > c l a s s S t a c k { s t d : : v e c t o r < T > r e p ; p u b l i c : v o i d p u s h ( c o n s t T & t ) ; T p o p ( ) ; b o o l i s _ e m p t y ( ) ; } ; - By adding the line t e m p l a t e < c l a s s T > before the class declaration, we are parameterizing s t a c k ’s declaration. Computer Science / Software Engineering Notes Network - In this case, T is the parameter. We can use T as a type anywhere we like. - Here, we’re using T as the type of the stack’s elements. - Now, we can declare any type of stack we like, using diamond operators to pass in types as T ! S t a c k < i n t > i n t S t a c k ; S t a c k < c h a r > c h a r S t a c k ; S t a c k < 🥞> p a n c a k e S t a c k ; With templates, you can make one of these in C++. - You may have noticed we used s t d : : v e c t o r < T > , even though T is itself a template parameter. - We can use template parameters as template arguments, too. - Classes are not the only declarations we can parameterize. - We can also parameterize struct and function definitions: t e m p l a t e < c l a s s T > T m i n ( c o n s t T & a , c o n s t T & b ) { i f ( a < b ) r e t u r n a ; e l s e r e t u r n b ; } - This function would work for i n t s, f l o a t s, d o u b l e s, or anything that supports a < operator. - Templates implement p arametric p o lymo rp hism. - That means we can write a function or data that still works without depending on certain types. - Templates: - make almost no assumptions about the template parameters (except copy constructors, destructors, and equality, which is common to all classes) - is similar to ML / Haskell, in the sense of polymorphic data types and functions - is not similar to Haskell, in the sense that template parameters have no type-checking - Templates are used for generic programming, like implementing type-agnostic data structures such as lists or stacks. Template Parameters - So what? Java has generics;you can make stacks of pancakes in Java too. Computer Science / Software Engineering Notes Network - Yes, but there is a difference between Java generics and C++ templates. - “Java generics suck and C++ templates suck a bit less”? - Now you’re getting it! - C++ templates can have different kinds of parameters: - Types - This is the most common case, denoted by the c l a s s keyword. We used this above. - You can also use the t y p e n a m e keyword, but there’s only a few instances where you should use this, which we’ll see later. - You also can’t use local classes as a template parameter. - Non-types (values) - This means we don’t have to pass in a type;we can pass in a value instead, like a number. - A non-type template parameter can accept one of the following (source): - Integral or enumeration type - Pointer to object or pointer to function - lvalue reference to object or lvalue reference to function - Pointer to a member - s t d : : n u l l p t r _ t - This only works with class templates. - Using this, we could set a size limit on our stack: t e m p l a t e < c l a s s T , i n t M a x > c l a s s S t a c k { . . . p u b l i c : . . . b o o l i s _ f u l l ( ) { r e t u r n s i z e = = M a x } } ; - Templates - Yes, we can even have higher-order templates. - Template template parameters let us put templates as parameters. - Let’s use an example: t e m p l a t e < t e m p l a t e < c l a s s T > c l a s s T T > c l a s s I n t s A n d C h a r s { T T < i n t > d a t a 1 ; T T < c h a r > d a t a 2 ; } I n t s A n d C h a r s < S t a c k > m y D a t a ; - In this example, we create an I n t s A n d C h a r s class that takes a class template as a parameter, and creates int and char instances of that class. Computer Science / Software Engineering Notes Network - We pass it the S t a c k class, and now our I n t s A n d C h a r s variable is handling a S t a c k < i n t > and a S t a c k < c h a r > internally. - We can also have default arguments for our template parameters: t e m p l a t e < c l a s s T = i n t , i n t M a x = 1 0 > c l a s s A { . . . } A < > ← T = i n t , M a x = 1 0 A < c h a r > ← T = c h a r , M a x = 1 0 A < c h a r , 7 > ← T = c h a r , M a x = 7 - You could use this to simulate variadic templates: s t r u c t n i l { } ; t e m p l a t e < c l a s s T , c l a s s U = n i l , c l a s s V = n i l > c l a s s T u p l e { . . . } ; t u p l e < i n t > t u p l e < i n t , c h a r > t u p l e < i n t , c h a r , s t d : : s t r i n g > Templates are Syntactic Macros - C++ templates are like C macros for classes, in the sense that they both work by editing the source code. - When C++ templates are “compiled”, class templates are instantiated into normal non-parameterized classes based on how you use them later on: t e m p l a t e < c l a s s T > c l a s s S t a c k { s t d : : v e c t o r < T > s ; p u b l i c : v o i d p u s h ( c o n s t T & t ) ; T p o p ( ) ; b o o l i s _ e m p t y ( ) ; } ; S t a c k < i n t > c l a s s _ _ S t a c k _ i n t { s t d : : v e c t o r < i n t > s ; p u b l i c : v o i d p u s h ( c o n s t i n t & t ) ; i n t p o p ( ) ; b o o l i s _ e m p t y ( ) ; } ; - After this, instead of using S t a c k < i n t > , the code will be using this new _ _ S t a c k _ i n t class instead. - Function templates can be implicitly instantiated. - This means we don’t have to specify types;we can let the compiler derive them. - Here’s explicit instantiation: m i n < i n t > ( 1 , 2 ) ; - Here’s implicit instantiation: : : m i n ( 1 , 2 ) ; Computer Science / Software Engineering Notes Network s t d : : s t r i n g s t r 1 ( \" C a t \" ) , s t r 2 ( \" H a t \" ) ; s t d : : s t r i n g f i r s t = : : m i n ( a , b ) ; - If the compiler can derive them, the type arguments can be left out. - This isn’t always possible though. - : : m i n refers to the member function in the implicit class. Why C ++ Templates Suck - There’s one small problem with this... - ... it sucks? - As with everything, according to Automated Code Generation, yes... it does have its drawbacks. - C++ templates use the in stan tiatio n mo del. - This means for every usage of the class template, another non-parameterized class is generated. - So if I used S t a c k < i n t > , S t a c k < c h a r > , and S t a c k < 🥞> , the compiler will generate three versions of the same stack class, but with different types. - Of course, if I used S t a c k < i n t > multiple times, it’ll use the same generated class (you could say it’s cached). - This is different from what Java does;they use the skeleto n co de mo del. - With that, Java uses the same skeleton class for all usages, but everything is downcast when they are used. - This makes things really slow. - So, there is a trade-off. The instantiation model is faster, but is prone to code bloat, especially if you use lots of class variations. - Oh, and not to mention, C++ template syntax is horrible when you use it like this. Templates Specialisation in C++ - You can provide specialised versions of templates, where you effectively “pattern match” on the template parameters. - Doing this is called temp late sp ecialisatio n . - You can do this to provide different implementations when certain parameters of the templates are provided. - Here’s an example of some specialised templates: / / P r i m a r y t e m p l a t e t e m p l a t e < c l a s s T , c l a s s U , c l a s s V > c l a s s t { . . . } ; / / P a r t i a l s p e c i a l i s a t i o n ; T , U , a n d V a r e p o i n t e r t y p e s t e m p l a t e < c l a s s T , c l a s s U , c l a s s V > Computer Science / Software Engineering Notes Network c l a s s t < T * U * V * > { . . . } ; / / P a r t i a l s p e c i a l i s a t i o n ; s o m e p a r a m e t e r s a r e i d e n t i c a l t e m p l a t e < c l a s s T , c l a s s U > c l a s s t < T , T , U > { . . . } ; t e m p l a t e < c l a s s T , c l a s s U > c l a s s t < T , U , U > { . . . } ; / / P a r t i a l s p e c i a l i s a t i o n ; a l l p a r a m e t e r s a r e i d e n t i c a l t e m p l a t e < c l a s s T > c l a s s t < T , T , T > { . . . } ; / / E x p l i c i t s p e c i a l i s a t i o n ; a l l m u s t b e i n t e g e r s t e m p l a t e < > c l a s s t < i n t , i n t , i n t > { . . . } ; - The compiler picks the most specialised instance. - The order of specialised templates is called the temp late sp ecialisatio n o rder. - We say that: - T1 is mo re sp ecialised than T2 (T1 ≥ T2) - iff: - “every template argument list that matches T1 also matches T2, but not vice versa” - T1 is maximally sp ecialised (with respect to a primary template T) iff it matches T and there is no more specialised T2 matching T. Example To make a template special,you just have to believe it’s special. T T1 T2 template <class A, class B> class c{ ... }; template <> class c<int, int> { ... }; template <class A> class c<A, A> { ... }; - With the above templates, T1 is more specialised than T2, because: - T1’s arguments match T2’s (A can be set to i n t ) - T2’s arguments do not match T1’s (i n t cannot be generalised to A) - In addition, T1 is maximally specialised because there are no templates that are more specialised than T1. - You could get a compile-time error if: - There is no matching instance (using c < c h a r > for the example above) - No unique maximally specialised template for instance (don’t understand what that means? Read the next example!) Computer Science / Software Engineering Notes Network Example Gay pride templates A template <class T, class U, class V> class t { ... }; B template <class T, class U, class V> class t<T*, U*, V*> { ... }; C template <class T, class U> class t<T, T, U> { ... }; D template <class T, class U> class t<T, U, U> { ... }; E template <class T> class t<T, T, T> { ... }; F template <> class t<int, int, int> { ... }; - Given these templates, which specialisation is selected? t < i n t , b o o l , i n t > A t < i n t , i n t , b o o l > C t < i n t , i n t , i n t > F - more specialised than E t < i n t * , b o o l * , i n t * > B t < i n t * , b o o l * , b o o l * > ERROR: both B and D are maximally specialised for this template. We have no idea which one to pick! - You can specialise on all template parameters, even non-type (value) ones. - So, for example, if a template accepts an i n t , you could specialise that with a constant, like 2 or 6. - It requires compile-time expressions, so you can use s t a t i c c o n s t or e n u m . - You cannot use input from the user, called dyn amic in p ut;you must use input that can be calculated at compile-time, called static in p ut. - You can perform conditionals through selection of most specialised instances. - So, we have conditionals, values, a state (through enums)... what does this all mean? - C++ templates are Turing complete! - It’s a compile-time programming language and... - ... yes, you guessed it. It sucks. - The slides call it “functional programming with bad syntax”. Computer Science / Software Engineering Notes Network Example Templates! - To do recursion with templates: - Implement the recursive step as the normal template - Implement the base case as a specialised template - We’ll implement factorial as an example: Recursive step Base case template <int N> struct Factorial { enum { RET = N * Factorial<N - 1>::RET }; }; template <> struct Factorial<0> { enum { RET = 1 }; }; - Now, if you try and use this template, the compiler will expand it out like so: Factorial<3>::RET; struct Factorial_3 { enum { RET = 3 * Factorial_2::RET }; }; struct Factorial_2 { enum { RET = 2 * Factorial_1::RET }; }; struct Factorial_1 { enum { RET = 1 * Factorial_0::RET }; Computer Science / Software Engineering Notes Network }; struct Factorial_0 { enum { RET = 1 }; }; - Your compiler can even optimise away constant expressions (since those values will never change, what’s the harm in computing them in advance and hard-coding them?): Factorial<3>::RET; struct Factorial_3 { enum { RET = 6 }; }; struct Factorial_2 { enum { RET = 2 }; }; struct Factorial_1 { enum { RET = 1 }; }; struct Factorial_0 { enum { RET = 1 }; }; - A TL;DR so far: - Templates define compile-time functions. - Specialisation is like pattern matching. - Template expansion is compile-time evaluation. - Using ‘enum’forces the compiler to evaluate values. - Template arguments are also evaluated, so the compiler knows which template specialisation to use. - Compiler optimisations clean up the generated program. - You can even mix-and-match compile-time and run-time arguments! No rmal bo rin g fully-dyn amic ‘p o wer’ fun ctio n To tally ep ic half-co mp ile-time half-run -time ‘p o wer’fun ctio n int power ( int n, int m) { if (n == 0 ) return 1 ; else if (n == 1 ) return m; else return m * power(n - 1 , m); } template < int n> int power ( int m) { return power<n - 1 >(m) * m; }template <> int power< 1 >( int m) { return m;} template <> int power< 0 >( int m) { return 1;} - The only thing is, if you use the half-compile-time version, your argument n must be a constant. - It cannot be a dynamic value provided by the user with stdin or something. - Partial evaluatio n :symbolically executes the program P for some given static inputs and constructs a residual program P’with the same behaviour for all dynamic inputs. Computer Science / Software Engineering Notes Network - 𝑃': 𝐼 𝑠𝑡𝑎𝑡𝑖𝑐 × 𝐼 𝑑𝑦𝑛𝑎𝑚𝑖𝑐 → 𝑂→𝑃': 𝐼 𝑑𝑦𝑛𝑎𝑚𝑖𝑐 → 𝑂 - In other words, it takes static inputs and a program P, and creates a new program P’where all the given static inputs are hard-coded. - This is analogous to our C++ compiler, “instantiating” templates (code generating, in a sense) during the compilation process with given static inputs (constants). - B in din g time an alysis:analyzes a program P to identify parts that can be evaluated statically (we don’t do this in C++). - Stagin g:annotates a program P to identify parts that can be evaluated statically. - In C++, we do ‘staging’through templates and other keywords, such as c o n s t e x p r . Template Metaprogramming - In C++ templates, we have: - Class templates → functions - Integers and types → data - Symbolic names → variables (e n u m s and t y p e d e f s ) - Lazy evaluation (templates only instantiated if struct is accessed via : : ) - Let’s make some templates so that it actually looks like a programming language. IF<> - We already have conditionals with specialisation. - But... if statements! Imperative! Functional programming scary 🥺 - Fine... let’s implement if statements. It’ll be syntactic sugar for specialisation. // Normal template is used when Cond = true template < bool Cond, class Then, class Else> struct IF { typedef Then RET; }; // Specialised template is used when Cond = false template < class Then, class Else> struct IF<false, Then, Else> { typedef Else RET; }; // Usage: IF< 1 == 0 , int , double >::RET f; // f is double IF< 1 == 1 , int , double >::RET g; // g is int - In the same way we use e n u m s to have integer fields, we can use t y p e d e f to have pointer fields. - We use t y p e d e f to point to either T h e n or E l s e as our return value R E T , depending on whether C o n d is true or false. Computer Science / Software Engineering Notes Network WHILE<> - We already have loops with recursion. - But... while loops! Imperative! Functional programming scary 🥺 - Alright... let’s implement while loops. It’ll be syntactic sugar for recursion. template < class State> struct STOP { typedef State RET; }; template < class Cond, class State> struct WHILE { typedef IF<Cond:: template Code<State>::RET, WHILE<Cond, typename State::Next>, STOP<State> >::RET::RET RET }; - You may wonder about the t e m p l a t e C o d e < S t a t e > part. - We assume C o n d contains a templated class called C o d e , which has a field called R E T that represents our while loop condition. - When A contains a templated class member called B , we reference that with A : : t e m p l a t e B < w h a t e v e r > . - You’ll also notice the strange t y p e n a m e S t a t e bit. - We use typename when we need to use a class member (extracted from a type) as a template parameter. - In this case, we need to use S t a t e ’s member N e x t as the second template argument for W H I L E . - It’s simply for parsing reasons. If you use a C++ IDE, it’ll probably spot that out for you. - We also assume S t a t e contains a class called N e x t , which represents the while loop condition in the next iteration. Example Fibonacci: the ‘hello world’of loops - Let’s implement Fibonacci normally: No rmal way // x == fib(i), y == fib(i-1) int i; int x; int y; i = 1 ; x = 1 ; y = 0 ; while ( i < n ) { i = i + 1; x = x + y; // fib(i+1) = fib(i)+fib(i-1) y = x; } Computer Science / Software Engineering Notes Network - We need to identify three things to “convert” this to WHILE<>: - State:the variables that are updated by the loop - integers i , x , and y - Code:loop condition - The predicate in the while loop;namely, i < n - Next:the new state after one iteration - i = i + 1 , x = x + y , y = x Temp late way template < int n> struct Fibonacci { enum { RET = WHILE<FibCond<n>, FibState< 1 , 1 , 0 > >::RET::x }; }; template < int i_, int x_, int y > struct FibState { enum { i = i_, x = x_ }; typedef FibState< i+1, x+y, x > Next; }; template < int n> struct FibCond { template < class State> struct Code { enum { RET = State::i < n }; }; }; Loop Unrolling - Have a look at this runtime-only, regular C++ code with no templates: inline void addVect ( int size, double *c, double *a, double *b) { while (size--) *c++ = *a++ + *b++; } - It adds vectors a and b and puts it into c . - According to Automated Code Generation, it sucks. - If we used C++ templates instead, it’d still suck, but it’d suck a little less. - How would we convert this to templates? - First off, let’s unpack this loop. What’s it actually doing? - Something along the lines of this: *c = *a + *b; Computer Science / Software Engineering Notes Network *(c + 1 ) = *(a + 1 ) + *(b + 1 ); *(c + 2 ) = *(a + 2 ) + *(b + 2 ); ...*(c + n ) = *(a + n ) + *(b + n ); - Well, a pretty simple way of doing this with templates would be: A p p ro ach #1 template < int n> inline void addVect ( double *c, double *a, double *b) { *c = *a + *b; addVect<n - 1 >(c + 1 , a + 1 , b + 1 ); } template <> inline void addVect< 0 >( double *c, double *a, double *b) { } - That works! - This generates a version of a d d V e c t from 0 to n. - But what if n was suuuuuper big? - Like, n = 1000 big? - We’d be repeating the same * ( c + ? ) = * ( a + ? ) + * ( b + ? ) code 1000 times. That’s bloat! - Let’s try things a different way. - Here’s an alternate approach: A p p ro ach #2 template < int n, class B> struct UNROLL { static void iteration ( int i) { B::body(i);UNROLL<n - 1 , B>::iteration(i + 1 ); } }; template < class B> struct UNROLL<0, B> { static void iteration ( int i) {} }; template < int n, class B> struct FOR { static void loop ( int m) { for ( int i = 0 ; i < m / n; i++) { UNROLL<n, B>::iteration(i * n); Computer Science / Software Engineering Notes Network }for ( int i = 0 ; i < m % n; i++) { B::body(n * m / n + i); } } }; // USAGE double *a, *b, *c; class AddVecBody {public : static inline void body ( int i) { *(c + i) = *(a + i) + *(b + i); } }; FOR< 4 , AddVecBody>::loop( 1000 ); - Alright... what on Earth 🌍is going on here? - This FOR template breaks up the loop into chunks. - Each chunk is of size n , so only n + 1 instantiations of the template have to be made (including the 0 specialisation). - For example, in the usage case here, we’re adding two 1000-element vectors in chunks of 4. - The UNROLL template executes a piece of ‘body’code a specified number of times with incrementing iteration values (e.g. given UNROLL<3, B>::iteration(7), then B::body(7), B::body(8) and B::body(9) would be called). - Because each chunk is size 4, only: - UNROLL<4, ...> - UNROLL<3, ...> - ... - UNROLL<0, ...> - ... need to be instantiated. - Every 4th element of the vector marks the start of a new unpack: - UNROLL<4, B>::iteration(0) (body(0), body(1), body(2), body(3)) - UNROLL<4, B>::iteration(4) (body(4), body(5), body(6), body(7)) - UNROLL<4, B>::iteration(8) (body(8), body(9), body(10), body(11)) - ... - UNROLL<4, B>::iteration(996) (body(996), body(997), body(998), body(999)) - This way, all ‘body’calls from 0 to 999 are called, and we don’t need to create 1000 versions of UNROLL to do it! Computer Science / Software Engineering Notes Network On the topic of rolling, here is sushi being rolled. A D Ts - If you did Algorithmics,you might remember what ADTs are. - You forgot? Tsk tsk... - They are the interfaces of data structures (e.g. pop and push for stacks). - How do we implement ADTs with templates? - The main ideas are: - Constructor functions → class templates - Implemented methods → class templates - Values → enums - Pointers → typedefs - Copy constructor arguments → local fields - Let’s think of a really simple ADT:a linked list! - You know, a list data structure that works through pointers pointing to the next element of the list: - How would we implement this through templates? - Firstly, we implement our constructor function C o n s . It stores our value and a pointer to the next element. - There we go;right from that description, we’ve identified a few things we could do: - Implement constructor function Cons as a class template - Implement stored value as an enum - Implement pointer to next element as a typedef - Remember to implement a special “Nil” structure, so our Cons template can point to some “null” value at the end of the list. No rmal co de Temp late co de struct Cons { struct Nil { Computer Science / Software Engineering Notes Network int head; Cons *tail; } enum { head = ERROR }; typedef Nil Tail; }; template < int head_, class Tail_ = Nil> struct Cons { enum { head = head_ }; typedef Tail_ Tail; } - There we go! We can now create linked lists: - C o n s < 1 , C o n s < 2 , C o n s < 3 , N i l > > > (1 → 2 → 3 → NULL) - But what use is a data structure if we can’t do anything with it? - There are loads of functions over lists, but we’ll implement a simple “length” function for now. - A ccording to our main ideas above,we should implement this as a class template as well. No rmal co de Temp late co de int Length (Cons *l) { if (l->tail == NULL) return 1 ; else return Length(l->tail) + 1 ; } template < class List> struct Length { enum { RET = Length< typename List::Tail>::RET + 1 }; }; template <> struct Length<Nil> { enum { RET = 0 }; }; - Now we can find the length of a list: - L e n g t h < C o n s < 1 , C o n s < 2 , C o n s < 3 , N i l > > > (result = 3) - Let’s do one more:the “append” function. - We should also implement this as a class template as well. No rmal co de Temp late co de void Append (Cons *list1, Cons *list2) { if (list1->tail == NULL ) list1->tail = list2; else Append(list1->tail, list2); } template < class L1, class L2> struct Append { typedef Cons<L1::head, typename Append< typename L1::Tail, L2 >::RET > RET; }; template < class L2> struct Append<Nil, L2> { typedef L2 RET; }; Computer Science / Software Engineering Notes Network - Now we can append elements to the end of a list: - A p p e n d < C o n s < 1 , C o n s < 2 , N i l > > , C o n s < 3 , N i l > > (result = 1 → 2 → 3 → NULL) Expression Templates - We can use templates to implement domain-specific languages. - We can do this by: - representing ASTs with expression templates. - implement AST transformations as class templates. - link ASTs to semantics (C++) with an eval method (we use inline for code generation) - provide syntactic sugar with overloaded operators - Let’s have an example:what domain-specific language should we implement? - How about vector addition? That’s simple enough. - It’s also on the slides, so I don’t have much of a choice. - We want to implement this concise syntax: - V e c t o r v , a , b , c ; - v = a + b + c ; - We’d like to generate it into this: - f o r ( u i n t i = 0 ; i < v . s i z e ( ) ; i + + ) - v [ i ] = a [ i ] + b [ i ] + c [ i ] ; - No temporary variables, and only a single pass through memory. - Why is this section called expression templates? - What are expression templates? - Exp ressio n temp lates encode ASTs using static types. - Templates construct compile-time expression representation, and fields are run-time values. - In other words, if we had something like ((a + b) + c), that expression structure would be encoded compile-time, but the actual values of a, b, and c are run-time values, so they don’t have to be constant (they could be provided by the user). - NOTE:I got really stuck trying to implement this myself. If you’ve got it working, please hmu with a pastebin or something so I can add it here pls ty 🙏 - Advantages: - You can implement domain-specific languages;really good abstraction - Disadvantages: - Clumsy template syntax - Limited applicability (you can only really do this with algebraic libraries) - Testing is difficult Aspect Oriented Programming with AspectJ - If you just want to skip to AspectJ and how to use it, go to Introduction to AspectJ. Computer Science / Software Engineering Notes Network - To generally learn what aspects are and why we use them, read ahead! - If you already know AspectJ, have a look at the official quick reference guide. Aspect Oriented Programming Concepts - Macros and aspects are co de-based tran sfo rmatio n s. - They change the underlying code before it’s compiled and run. - Macros use exp licit in vo catio n (you invoke the macro where it is to be run). - Aspects use imp licit in vo catio n (you tell the aspect where it must perform). - C o n cern :specific requirement or consideration that must be addressed in order to satisfy the overall system goal. - Functionality - Efficiency - Reliability - User interface - In other words, a concern is something you want to implement in your project. - It could be many things: - Logging - Error handling - Security - A ctual business logic - To illustrate this, let’s say we had a function that adds a new ‘User’record with SQL: addUserRecord(user_record) { if (user_record.age < 0) { println(\"Failed to add user; invalid age\"); throw new InvalidFieldException(\"Please input a valid age!\"); } if (sql_in(user_record.name) || sql_in(user_record.age)) { println(\"Failed to add user; SQL injection detected\"); throw new SQLInjectionException(\"SQL injection detected!\"); }var sql = \"INSERT INTO User (name, age) VALUES ($user_record.name, $user_record.age)\"; println(\"Adding new user...\"); var success = execute_sql(sql); if (success) println(\"Added new user successfully!\"); else { println(“Failed to create new user; rolling back”); rollback(); } } - Eugh... there’s colours all over. The concerns are all coupled with each other! - These are called cro ss-cuttin g co n cern s:implementation that spans across multiple code units. - As a wise man once said... Computer Science / Software Engineering Notes Network - We should separate our concerns so they’re not coupled together. - Wouldn’t it be nice if we could do this...? error_handling { before addUserRecord(user_record) { if (user_record.age < 0) throw new InvalidFieldException(“Please input a valid age!”); }after addUserRecord(success) { if (!success) rollback(); } } security { before addUserRecord(user_record) { if (sql_in(user_record.name) || sql_in(user_record.age)) throw new SQLInjectionException(“SQL injection detected!”); } } logging { before execute_sql { println(“Adding new user...”); }after addUserRecord(success) { if (success) println(“Added new user successfully!”); }before rollback() { println(“Failed to create new user; rolling back”); }after addUserRecord throwing InvalidFieldException { println(“Failed to add user; invalid age”); }after addUserRecord throwing SQLInjectionException { println(“Failed to add user; SQL injection detected”); } Computer Science / Software Engineering Notes Network } addUserRecord(user_record) { var sql = \"INSERT INTO User (name, age) VALUES ($user_record.name, $user_record.age)\"; var success = execute_sql(sql); return success; } - Woo hoo! Our concerns are now grouped together, all nicely. - So, what’s going on here? - Those coloured blocks are our aspects. They contain code (also called advice) to inject, and where to inject it. - We tell the aspects where to inject the code using pointcut descriptors, which describe join points. - For example, in the first code block in the logging aspect, the pointcut descriptor “before execute_sql” describes a single join point:just before the ‘execute_sql’ function is called (this isn’t real AspectJ mind you;just aspect pseudo-code). - A small piece of code to log the message “Adding new user...” is injected just before calls to ‘execute_sql’. - Here are some definitions: - Jo in p o in t:a point in the program execution where a cross-cutting concern might intervene. - Jo in p o in t mo dels: - Static:join points described by code patterns - D yn amic:join points described by control flow - Even t-based:when condition C arises, perform action A - Po in tcut descrip to rs:syntactic constructs that describe a set of join points. - A dvice:code that belongs to cross-cutting concerns - A sp ect:packs pointcuts and advice into a syntactic unit - There are loads more, like: - Different ways to describe join points - Capturing arguments and return values - Aspect state - Declaring stuff within classes that already exist - Want to know more? - Or are you completely confused? - Or do you just want to get on with your ACG revision already? - Then read on... Introduction to AspectJ - Create an aspect like this: Computer Science / Software Engineering Notes Network public aspect MyAspect { // aspect code } - In an aspect, you have pointcuts (setter() ) which describe join points (calls to methods that start with ‘set’ and return nothing) : public aspect MyAspect { pointcut setter () : call ( void set*(*) ); } - You can use these pointcuts to inject advice code (println calls) in a specific position using advice specs (before , after , around etc.): public aspect MyAspect { pointcut setter () : call ( void set*(*) ); before(): setter() { System.out.println( \"I am before the setter call!\" ); } after(): setter() { System.out.println( \"I am after the setter call!\" ); } around(): setter() { System.out.println( \"I am here instead of the setter call!\" ); } // can also substitute pointcut directly before(): call( void set*(*)) { System.out.println( \"I am before the setter!\" ); } } - You can have local mutable state in aspects: public aspect MyAspect { int count = 0 ; pointcut setter () : call ( void set*(*) ); before(): setter() { count++;System.out.println( \"You have setted \" + count + \" times so far.\" ); } } - You can describe many different Java concepts: Pattern type Syntax Examples M e t h o d P a t t e r n return_type classpath . method ( params ) int Adder.add(int[]) public static void main(*) Computer Science / Software Engineering Notes Network F i e l d P a t t e r n type class . field static int T.x private final int MAX_NUMS C o n s t r u c t o r P a t t e r n classpath .new( params ) org.main.Dog.new()MyString.new(char[]) T y p e P a t t e r n type intcharObjectNullPointerException - Patterns support wildcards: - Plain (*):matches Java syntax elements in the same context - public * *(int) → public return_type name (int param1 ) - * * *(*, *) → accessibility return_type name ( type1 param1 , type2 param2 ) - Lexical (*):matches names as in regular expressions - * *set*(int) → return_type any set any (int param1 ) - * *.set*(int) → return_type class .set any (int param1 ) - List ellip sis (..):matches arbitrary parameter / package / class name lists - * *(int, ..) → return_type name (int param1 , ...) - * swing..*(..) → return_type swing. ... . name (...) - Sub-typ e (+):matches sub-types of given base type - Figure+.new() → Figure constructor, ChildFigure constructor etc. - There are many kinds of pointcuts: Pointcut type Syntax Description Method execution execution( MethodPattern ) Captures method execution in its class. Method call call( MethodPattern ) Captures method calls from its parent scope. C onstructor execution execution( ConstructorPattern ) Captures constructor execution in its own class. C onstructor call call( ConstructorPattern ) Captures constructor calls from its parent scope. Object pre-initialisation preinitialization( ConstructorPattern ) Captures the moment just before an object is initialised. Can only be used with constructors . Object initialisation initialization( ConstructorPattern ) Captures the moment an object is initialised. Can only be used with constructors. Static initialisation staticinitialization( ConstructorPattern ) Captures the moment a static object is initialised. Field set set( FieldPattern ) Captures property mutation. Field get get( FieldPattern ) Captures property access. Handler execution handler( TypePattern ) Captures execution of exception handlers. Computer Science / Software Engineering Notes Network A dvice execution adviceexecution() Captures execution of advice. - Not enough pointcuts for you? Are you not entertained? - You can find more detail in the official guide. Call vs Execution - By using c a l l and e x e c u t i o n , you can inject code when methods are run. - The difference is this: - c a l l will refer to the call site (where the method is called:the parent scope) - e x e c u t i o n will refer to the declaration site (where the method is declared:the belonging class) class Main { void main () { var v = new MyValue(); v.getValue(); // ← call(MyValue.getValue()) } } class MyValue { public int getValue () { // ← execution(MyValue.getValue()) return 2 ; } } - On their own, they don’t make a lot of difference, but combined with other pointcuts (such as this / target), behaviour is different. State-Based Pointcuts - You can capture the current / target object with t h i s / t a r g e t : - t h i s :the object you are in - t a r g e t :the object you are invoking / referencing (source) class Main { void main () { var v = new MyValue(); v.getValue(); // ← call(MyValue.getValue()) } } class MyValue { public int getValue () { // ← execution(MyValue.getValue()) return 2 ; } } calltarget → instance of MyValue this → instance of Main executiontarget → instance of MyValue this → instance of MyValue Computer Science / Software Engineering Notes Network - Call and execution won’t affect ‘target’, because the method is the same regardless. - However, ‘this’changes between call and execution, because: - ‘this’via ‘call’refers to the parent scope - ‘this’via ‘execution’refers to the object that the method belongs to - You can use them like this: public aspect MyAspect { // Only using target / this as a 'guard' using a TypePattern before(): call(* *.getValue()) && target(MyValue+) { ... } // Capturing target / this in a parameter before(MyValue mv): call(* *.getValue()) && target(mv) { ... } before(Main main): call(* *.getValue()) && this (main) { ... } before(MyValue mv): execution(* *.getValue()) && target(mv) { ... } before(MyValue mv): execution(* *.getValue()) && this (mv) { ... } } - If you’re capturing the main method, you shouldn’t use ‘call’, because nothing is calling main, therefore ‘this’won’t make sense. - You can also capture arguments using a r g s : class Main { void main () { MyValue.setValue( 2 ); } } class MyValue { public static void setValue ( int val) { ... } } public aspect MyAspect { // You can also use ‘args’ as a guard using a TypePattern before(): call(* *.setValue(*)) && args( int ) { ... } // ... or capture arguments in a parameter before( int arg): call(* *.setValue(*)) && args(arg) { // arg == 2 } } - You can get the return value using a f t e r and r e t u r n i n g : public aspect MyAspect { after() returning( int i): call( int *.getInt()) { System.out.println( \"Returned value:\" + i); } } Computer Science / Software Engineering Notes Network Class JoinPoint - You can capture join points within a specified scope using w i t h i n and w i t h i n c o d e . - w i t h i n uses a T y p e P a t t e r n (classes) - w i t h i n c o d e uses a M e t h o d P a t t e r n (methods and constructors) class Main { void main () { MyValue.setValue( 2 ); } } class MyValue { public static void setValue ( int val) { ... } } public aspect MyAspect { // Captures call to setValue within a class that’s not in standard Java library before(): call(* *.setValue(*)) && !within(java..*) { ... } // Captures call to setValue within the main method in Main before(): call(* *.setValue(*)) && withincode(* Main.main()) { ... } } - You can get pointcut properties using t h i s J o i n P o i n t . - You can use i f statements in pointcuts (but they should have no side-effects): public aspect MyAspect { // Captures call to method when array passed in has more than 2 elements before(int[] arr): call(* *.method(*)) && args(arr) && if(arr.length > 2) { ... } } Advice Placement - You can replace join point code with a r o u n d . Just be sure to include the return type of the method before the a r o u n d keyword: public aspect MyAspect { Object around () : call (* *(..) ) { // ... Object result = proceed(); // ← invokes original join point code return result; } } - You can capture method definitions that throw exceptions, and aspects can throw exceptions too: public aspect FailureHandling { final int N = 3 ; pointcut getReplyMethod () : call ( int *.getReply() throws RemoteException) Computer Science / Software Engineering Notes Network int around () throws RemoteException: getReplyMethod () { int retry = 0 ; while ( true ) { try { return proceed(); }catch (RemoteException ex) { System.out.println( \"Encountered \" + ex); retry++;if (retry == N) throw ex; System.out.println( \"Retrying...\" ); } } } CFlow - You can capture join points based on its current control flow with c f l o w and c f l o w b e l o w : public class Main { void main () { FIB( 3 ); } void FIB ( int n) { // Just your average recursive fibonacci implementation if (n == 0 ) return 0 ; return FIB(n - 1 ) + n; } } public aspect MyAspect { pointcut fib () : call ( void FIB( int ) ) pointcut p1 () : fib () && cflow (fib() ) // ← Captures FIB(3), FIB(2), FIB(1) and FIB(0) pointcut p2 () : fib () && cflowbelow (fib() ) // ← Captures FIB(2), FIB(1) and FIB(0) pointcut p3 () : fib () && !cflow (fib() ) // ← Captures nothing pointcut p4 () : fib () && !cflowbelow (fib() ) // ← Captures only top-level FIB(3) } F I B ( 3 ) c f l o w F I B ( 3 ) c f l o w b e l o w F I B ( 3 ) F I B ( 2 ) F I B ( 2 ) F I B ( 1 ) F I B ( 1 ) F I B ( 0 ) F I B ( 0 ) ! c f l o w F I B ( 3 ) ! c f l o w b e l o w F I B ( 3 ) Computer Science / Software Engineering Notes Network F I B ( 2 ) F I B ( 2 ) F I B ( 1 ) F I B ( 1 ) F I B ( 0 ) F I B ( 0 ) Inter-Type Declarations - You can declare properties and methods in other classes: public aspect MyAspect { private String Line.label = \"\" ; // ← String label is now in Line class public void Line.setLabel(String s) { // ← setLabel is now in Line class label = s; }public String Line.getLabel() { // ← getLabel is now in Line class return label; } } - Inter-typed code can: - see aspect methods - cannot see aspect fields - can only see public interfaces of target class - Privileged aspects can see private / protected. Make them privileged by adding the p r i v i l e g e d keyword: class Line { protected String protecc; private String privatesOohLaLa; } public privileged aspect MyAspect { public String Line.letMeSeeYourPrivates() { // ← can see Line's privates String iCanSeeThis = protecc; return privatesOohLaLa; } } - Aspects can create marker in terfaces, populate them, and add new inheritance links (make other classes inherit them): public class Dog {} public aspect Barking { public interface Barker {} // Marker interface 'Barker' public void Barker.bark() { // Populating marker interface with 'bark' method System.out.println( \"Woof!\" ); } Computer Science / Software Engineering Notes Network declare parents : Dog extends Barker; // Dog now inherits Barker // Pointcut that captures Dog constructor and binds created Dog instance pointcut dogConstructor (Dog dog) : initialization (Dog.new() ) && target (dog) ; after(Dog dog) : dogConstructor(dog) { dog.bark(); // Can now use 'bark' method in any Dog } } - You can do compile-time static checks to make sure certain join points are not captured: public aspect MyAspect { pointcut illegalNew () : call (FigureElement+.new(..) ) && // Calling constructor !withincode (* FigureElementFactory.mk*(..) ); // Not in a factory method declare error: illegalNew() : // Static check \"Use factory method\" ; } - You must use a static pointcut to do this though (in other words, don’t use args, this, target, if, cflow, or cflowbelow). Why AspectJ Sucks - No way... AspectJ sucks too?! - Alas, everything sucks according to Automated Code Generation. - Why does AspectJ suck? - According to Meta-AspectJ’s homepage, you can’t provide support for characteristics not evident in names (for example, you can’t write an aspect for all classes that do not implement a particular interface). - In other words, AspectJ simply isn’t powerful and expressive enough for certain use cases. - Just before you delete all your coursework, let me show you how you can make AspectJ not suck. - You use Meta-AspectJ! Quote-Based Metaprogramming - Before we dive into Meta-AspectJ, let’s go over metaprogramming. - A meta-p ro gram is a program that represents and manipulates programs as data objects at its run-time. - A few examples are: Computer Science / Software Engineering Notes Network - Parser, compiler - Profiler, partial evaluator - Code generator - A meta-p ro grammin g lan guage provides language support to represent programs as data objects (reflection). - A few examples of that are: - Java with its Reflection API - Prolog with clause/3, assert/1, retract/1 - But how should we represent these programs in our code? - Text? - Oof, no... it holds no information about the grammar, and would be a pain to navigate through. - Objects? - Getting better, but clumsy. - It’s usually based on compiler AST exposed by reflection - Built using constructors - ASTs with quote and unquote? - Now we’re talking! - Here’s the basic idea: #1: Let the co mp iler build the A ST #2: Sp lice meta-level values in to A ST V a r D e c = ` [ i n t i ; ] ; O b j e c t l a n g u a g e ( A s p e c t J ) G l u e l a n g u a g e ( M e t a - A s p e c t J ) M e t a l a n g u a g e ( M e t a - A s p e c t J ) V a r D e c = ` [ i n t i ; ] ; C l a s s c l = F o o . c l a s s ; C l a s s D e c c = ` [ c l a s s # [ c l . g e t N a m e ( ) ] { # v } ] ; - #3: ??? - #4: Pro fit - For some strange reason, the splicing keyword ‘#’is called ‘un q uo te’. Unintuitive, but now you know. - This is what Meta-AspectJ is all about! - Meta-A sp ectJ:a language tool for generating Java and AspectJ programs using code templates. - Yep;aspects generated Java code, and now we’re generating aspects.... - ... and before you ask, the next section isn’t about generating Meta-AspectJ code. - Worry not, because the syntax for Meta-AspectJ is surprisingly simple! - All you need to remember are these few points and some Java reflection and you’ll be fine. Computer Science / Software Engineering Notes Network - These subsections come straight from the Meta-AspectJ tutorial, so check it out if you’re interested. Entry Points - In Meta-AspectJ, there is a fixed set of entry points. - En try p o in ts are non-terminals in the AspectJ grammar, that may be quoted or unquoted. - Basically, when you quote some AspectJ code, that quote will return a certain AspectJ type. - The different types that quotes may return are the entry points, and the type of a quote depends on what you’re quoting. - Here’s a copy of the table from the Meta-AspectJ tutorial: En try Po in t A ST C lass (all paths prefixed by o r g . a s p e c t j . c o m p i l e r ) c l a s s i n t e r f a c e Examp le Single Identifier b a s e . a s t . I D E N T I D E N T f o o = ` [ M y C l a s s ] ; Identifier b a s e . a s t . I d e n t i f i e r I d e n t i f i e r f o o = ` [ j a v a . u t i l . V e c t o r ] ; Identifier Pattern c r o s s c u t s . a s t . N a m e P a t t e r n N a m e P a t t e r n f o o = ` [ * ] ; N a m e P a t t e r n b a r = ` [ j a v a . l a n g . * ] ; Modifiers b a s e . a s t . M o d i f i e r s M o d i f i e r s f o o = ` [ p u b l i c s t a t i c ] ; Import b a s e . a s t . I m p o r t I m p o r t f o o = ` [ i m p o r t j a v a . l a n g . * ; ] ; Type Spec. b a s e . a s t . T y p e D T y p e D f o o = ` [ M y C l a s s ] ; T y p e D b u i l t I n = ` [ i n t ] ; Formal Declaration b a s e . a s t . F o r m a l D e c F o r m a l D e c f o o = ` [ i n t x ] ; Variable Declaration b a s e . a s t . V a r D e c V a r D e c f o o = ` [ i n t x = 0 ; ] ; V a r D e c b a r = ` [ O b j e c t x , y ; ] ; Expression b a s e . a s t . J a v a E x p r J a v a E x p r m y I n t = ` [ 3 2 ] ; J a v a E x p r m y B o o l = ` [ t r u e & & m y I n t = = 3 2 ] ; J a v a E x p r m y M e t h C a l l = ` [ a . f o o ( 3 , 5 ) ; ] ; Statement b a s e . a s t . S t m t S t m t m y I n c r = ` [ x + + ; ] ; S t m t m y F o r = ` [ f o r ( i n t x = 0 ; x < 5 ; x + + ) { f o o ( x ) ; } ] ; S t m t m y E m p t y = ` [ { } ] ; Method Declaration b a s e . a s t . M e t h o d D e c M e t h o d D e c m e t h 1 = ` [ p u b l i c v o i d g e t Y ( ) { r e t u r n y ; } ] ; Constructor Declaration b a s e . a s t . C o n s t r u c t o r D e c C o n s t r u c t o r D e c m y C o n s = ` [ p u b l i c F o o ( ) { } ] ; Computer Science / Software Engineering Notes Network Class Declaration b a s e . a s t . C l a s s D e c C l a s s D e c c l a s s F o o = ` [ p u b l i c c l a s s F o o { p u b l i c s t a t i c f i n a l i n t x = 0 ; } ] ; Interface Declaration b a s e . a s t . I n t e r f a c e D e c I n t e r f a c e D e c m y I n t e r f a c e = ` [ p u b l i c i n t e r f a c e m y I n t e r f a c e { p u b l i c v o i d f o o ( ) ; } ] ; Compilation Unit Member (Java) b a s e . a s t . C l a s s M e m b e r Any Class Declaration or Interface Declaration Compilation Unit Member (AspectJ) b a s e . a s t . A s p e c t M e m b e r Any Class Declaration, Interface Declaration, or Aspect Declaration Compilation Unit b a s e . a s t . C o m p U n i t C o m p U n i t m y C o m p U n i t = ` [ i m p o r t j a v a . l a n g . * ; i m p o r t j a v a . u t i l . * ; p u b l i c c l a s s F o o { p r i v a t e i n t m _ i X = 0 ; p u b l i c F o o ( ) { } } ] ; Intertype Declare c r o s s c u t s . a s t . D e c l a r e D e c D e c l a r e D e c d 1 = ` [ d e c l a r e p a r e n t s : m y C l a s s i m p l e m e n t s j a v a . i o . S e r i a l i z a b l e ] ; Advice Declaration c r o s s c u t s . a s t . A d v i c e D e c A d v i c e D e c m y A d v = ` [ b e f o r e ( ) : c a l l ( v o i d s e t * ( * ) ) { } ] ; Pointcut c r o s s c u t s . a s t . P c d P c d p c d 1 = ` [ c a l l ( v o i d F o o . m ( i n t , i n t , . . . ) ) ] ; P c d p c d 2 = ` [ e x e c u t i o n ( F o o . n e w ( i n t ) ) ] ; Pointcut Declaration c r o s s c u t s . a s t . P o i n t c u t D e c P o i n t c u t D e c p d e c = ` [ p r i v a t e p o i n t c u t f o o ( O b j e c t o ) ; ] ; Aspect Declaration c r o s s c u t s . a s t . A s p e c t D e c A s p e c t D e c m y A s p e c t = ` [ p u b l i c a s p e c t F o o { d e c l a r e p r e c e d e n c e : S e c u r i t y , L o g g i n g ; b e f o r e ( ) : c a l l ( v o i d s e t * ( * ) ) { } } ] ; - For more info about the API, check out the docs here! Using ` and # - You’ve already seen this, but we use this syntax: ` [ A s p e c t J c o d e h e r e ] - ... to quote some code and put it into a variable. - You can also interpolate quoted code into other quotes, called sp licin g: Computer Science / Software Engineering Notes Network I d e n t i f i e r m y I d e n t = ` [ f o o ] ; V a r D e c m y V a r = ` [ i n t # m y I n d e n t = 0 ; ] ; / / i n t f o o = 0 ; - Make sure you’re constructing valid Java code, because it’ll know! - You can splice quoted code, or regular variables (as long as it makes sense). - There’s two ways to splice: # i d # [ e x p r e s s i o n ] I d e n t i f i e r n a m e = ` [ f o o ] ; i n t v a l = 2 ; V a r D e c d e c = ` [ i n t # n a m e = # v a l ; ] ; / / i n t f o o = 2 ; i n t b a s e V a l = 6 ; V a r D e c d e c = ` [ i n t f o o = # [ b a s e V a l + 1 0 ] ; ] ; / / i n t f o o = 1 6 ; - You can explicitly set the type of the quote using rounded brackets just after the ` in the quote, or # in the splice: D c l v = ` ( D c l ) [ i n t x = 0 ; ] ; S t m s = ` ( S t m ) [ i f ( # ( D c l ) v ) x + + ; ] ; / / b a d D c l c = ` ( D c l ) [ c l a s s C { # ( D c l ) v } ] ; / / O K Using infer - Instead of looking up the types of the quotes all the time, you can use the i n f e r keyword to ‘infer’the type of the quote: i n f e r t y p e = ` [ i n t ] ; i n f e r n a m e = ` [ f o o ] ; i n f e r v a l u e = ` [ 2 ] ; i n f e r m y V a r = ` [ # t y p e # n a m e = # v a l u e ] ; / / i n t f o o = 2 ; - It’s like Java’s v a r , but before v a r was created. - One thing about infer is that you must initialise the variable right away: i n f e r t y p e ; / / B o o ! 👎 i n f e r n a m e = ` [ f o o ] ; / / Y a y ! 👍 Unquote Splice - What if you have some repetition that you want to quote, like parameters, or a long list of methods? - You can un q uo te sp lice, which is a special kind of splicing where you can splice in an array of elements into quoted code. - Here’s two examples: Parameters C lass metho ds F o r m a l D e c [ ] a r g s = n e w F o r m a l D e c [ 5 ] ; S t r i n g [ ] s t r i n g s = n e w S t r i n g [ ] { Computer Science / Software Engineering Notes Network / / C r e a t e s a r g u m e n t s f o r ( i n t i = 0 ; i < 5 ; i + + ) a r g s [ i ] = ` [ i n t p # i ] ; / / C r e a t e s f u n c t i o n f r o m a r g u m e n t s i n f e r f u n c = ` [ i n t f u n c ( # a r g s ) { } ] ; / * O u t p u t : i n t f u n c ( i n t p 0 , i n t p 1 , i n t p 2 , i n t p 3 , i n t p 4 ) { } * / \" J u l i a n \" , \" R a t h k e \" , \" L o v e s \" , \" M o n a d s \" } ; M e t h o d D e c [ ] m e t h o d s = n e w M e t h o d D e c [ s t r i n g s . l e n g t h ] ; / / C r e a t e s m e t h o d s f r o m s t r i n g s f o r ( i n t i = 0 ; i < s t r i n g s . l e n g t h ; i + + ) { S t r i n g s t r i n g = s t r i n g s [ i ] ; i n f e r m e t h o d = ` [ p u b l i c v o i d # s t r i n g ( ) { } ] ; m e t h o d s [ i ] = m e t h o d ; } / / C r e a t e s c l a s s i n f e r m y C l a s s = ` [ p u b l i c c l a s s M y C l a s s { # [ m e t h o d s . t o A r r a y ( ) ; ] } ] ; / * O u t p u t : p u b l i c c l a s s M y C l a s s { p u b l i c v o i d J u l i a n ( ) { } p u b l i c v o i d R a t h k e ( ) { } p u b l i c v o i d L o v e s ( ) { } p u b l i c v o i d M o n a d s ( ) { } }* / Convenience Methods - In this section, we’ll go over some useful tidbits in Meta-AspectJ you might find yourself doing down the line. - The first is pretty simple:the u n p a r s e method. - It’s in ASTObject, which means it’s in every quote object, and it converts the quoted code to a string. - It’s useful for printing out quoted code, either for debugging or writing to a file: Computer Science / Software Engineering Notes Network i n f e r v a r = ` [ i n t x = 1 ; ] ; v a r . u n p a r s e ( ) ; / / “ i n t x = 1 ; ” - Now, this is where the tutorial ends, but I’m going to drop in some useful Meta-AspectJ and reflection tidbits. - This is how to add methods to a quoted class: i n f e r m y C l a s s = ` [ c l a s s M y C l a s s { } ] ; i n f e r m y M e t h o d = ` [ p u b l i c v o i d a d d O n e ( i n t x ) { r e t u r n x + 1 ; } ] ; / / C l a s s D e c h a s a n a d d M e t h o d m e t h o d m y C l a s s . a d d M e t h o d ( m y M e t h o d ) ; - To add methods and fields to existing classes, use inter-type declarations in aspects: p u b l i c v o i d a d d M e t h o d ( S t r i n g c l a s s N a m e , S t r i n g m e t h o d N a m e ) { i n f e r d e c l a r a t i o n = ` [ p u b l i c v o i d # c l a s s N a m e . # m e t h o d N a m e ( ) { } ] ; i n f e r a s p e c t = ` [ p u b l i c a s p e c t # [ c l a s s N a m e + m e t h o d N a m e ] { # d e c l a r a t i o n } ] ; S y s t e m . o u t . p r i n t l n ( a s p e c t . u n p a r s e ( ) ) ; } p u b l i c v o i d a d d F i e l d ( S t r i n g c l a s s N a m e , S t r i n g f i e l d N a m e ) { i n f e r d e c l a r a t i o n = ` [ p u b l i c i n t # c l a s s N a m e . # f i e l d N a m e ] ; i n f e r a s p e c t = ` [ p u b l i c a s p e c t # [ c l a s s N a m e + f i e l d N a m e ] { # d e c l a r a t i o n } ] ; S y s t e m . o u t . p r i n t l n ( a s p e c t . u n p a r s e ( ) ) ; } - To get a Class by name, use the C l a s s . f o r N a m e method: p u b l i c c l a s s M y C l a s s e x t e n d s M y O t h e r C l a s s { i n t x , y ; p u b l i c M y C l a s s ( ) { . . . } p u b l i c M y C l a s s ( i n t x ) { . . . } p u b l i c i n t g e t X ( ) { . . . } p u b l i c i n t g e t Y ( ) { . . . } } C l a s s m y C l a s s = C l a s s . f o r N a m e ( \" M y C l a s s \" ) ; - Once you have a Class, you can fetch virtually anything about a class: m y C l a s s . g e t N a m e ( ) / / R e t u r n s t h e c l a s s n a m e : ' M y C l a s s ' m y C l a s s . i s I n t e r f a c e ( ) / / C h e c k s i f i t i s a n i n t e r f a c e : ' f a l s e ' m y C l a s s . i s A r r a y ( ) / / C h e c k s i f i t i s a n a r r a y : ' f a l s e ' m y C l a s s . i s P r i m i t i v e ( ) / / C h e c k s i f i t i s p r i m i t i v e : ' f a l s e ' m y C l a s s . g e t S u p e r c l a s s ( ) / / R e t u r n s s u p e r c l a s s r e f e r e n c e : M y O t h e r C l a s s m y C l a s s . g e t D e c l a r e d F i e l d s ( ) / / F i e l d s : [ i n t x , i n t y ] Computer Science / Software Engineering Notes Network m y C l a s s . g e t D e c l a r e d M e t h o d s ( ) / / M e t h o d s : [ i n t g e t X ( ) , i n t g e t Y ( ) ] m y C l a s s . g e t D e c l a r e d C o n s t r u c t o r s ( ) / / C o n s t r u c t o r s : [ M y C l a s s , M y C l a s s ( i n t x ) ] m y C l a s s . g e t D e c l a r e d M e t h o d ( \" g e t X \" , n e w C l a s s [ 0 ] ) / / R e t u r n s s p e c i f i e d m e t h o d - There’s even more methods for Fields and Methods! Why Meta-AspectJ Sucks - Wha... Meta-AspectJ ALSO sucks?! - Indeed: 1. Everything sucks 2. Meta-AspectJ is a part of ‘everything’ 3. Therefore, Meta-AspectJ sucks - What’s the reason this time? 1. For one thing, it’s Java only. 2. Secondly, it’s so meta that you’d probably end up tangling yourself if you were to use this in a big project. - Let’s be honest:do you really see yourself using this anytime soon? 3. Thirdly, it’s quite obscure. - Have you tried looking up questions about Meta-AspectJ? 4. Fourthly, I want to keep the pattern going for my own amusement. - Alright, well, we can kind of solve the first one. - In Meta-AspectJ, we were working with Java ASTs. - What if we had a different tool, but we could work with any language ASTs in a variety of other target languages? - Interested? - Allow me to up the ante and say that, with this new tool, we can work with ASTs in any conceivable language? - Alright, that’s dramatising it a bit. Just read the next section. 🙂 Transformative Code Generation - This section is all about A NTLR (A Nother Tool for Language Recognition). - It’s a tool that lets you create parsers, like lex and yacc back in PLC. - Download it from here! Computer Science / Software Engineering Notes Network If you remember (or even did) Programming Language Concepts, ANTLR won’t be so hard. Let’s Get Meta! - This section is a “notes adaptation” of the Let’s Get Meta section of the ANTLR book. - To implement a language, you need an in terp reter:an application that computes or “executes” sentences. - Also, we’d use a tran slato r for converting sentences from one language to another. - Programs recognise languages using p arsers (or syn tax an alysers):programs that recognise languages. - They do this using a grammar:set of rules to express a language. - They first perform lexical an alysis and break the source code into a p arse tree / syn tax tree / abstract syn tax tree. - The leaves of the tree are always input tokens. Matt’s Teach Yourself ANTLR in 2 minutes - A NTLR is similar to B ackus-Naur form back in PLC . - A n A NTLR grammar starts with: - A ‘grammar’line to define the name of the grammar - A ‘prog’line to define the starting grammar rule, where parsing begins (this is just a grammar rule,and can be anything you want;calling it ‘prog’to signify the root is a convention) g r a m m a r m y G r a m m a r N a m e ; p r o g : g r a m m a r R u l e s F o r T h i s L a n g u a g e ; - A grammar rule starts with a name, then a colon :, then the rule itself, and ends with a semicolon ; - You can add alternatives (different parsing paths) with the bar | m y r u l e : a l t e r n a t i v e 1 | a l t e r n a t i v e 2 | a l t e r n a t i v e 3 ; - There are non-terminals and terminals. - Non-terminals are the rules we define:they can be split further - Terminals are the constants that cannot be split further - You can express terminals using a regex-like syntax. Functionality Example Accepted sentences Computer Science / Software Engineering Notes Network Strings H E L L O : ‘ h e l l o ’ ; h e l l o b r a c k e t _ i n t : ‘ ( ‘ I N T ‘ ) ’ ; ( 5 ) ( 2 6 ) ( 4 5 6 ) Or V O W E L : ( ‘ a ’ | ‘ e ’ | ‘ i ’ | ‘ o ’ | ‘ u ’ ) ; aeiou Match anything in set V O W E L : [ a e i o u ] ; aeiou Range D I G I T : [ 0 - 9 ] ; 279 A L P H A : [ 0 - 9 a - z A - Z ] ; 8yB 0or more M A N Y _ C : ‘ c ’ * ; ( n o t h i n g ; e m p t y s t r i n g ) cc c c c 1or more I N T : D I G I T + ; 34 6 7 7 2 3 0or 1 P L U R A L : ‘ o n e ’ ‘ s ’ ? o n e o n e s - There are two kinds of rules:lexer rules and parser rules. Lexer rules Parser rules - D enoted in UPPER C A SE. - D escribes tokens I D : [ a - z A - Z ] + ; I N T : [ 0 - 9 ] + ; N E W L I N E : ‘ \\ r ’ ? ‘ \\ n ’ ; W S : [ \\ t ] + - > s k i p ; - Denoted in lower case. - Describes syntax s t a t : e x p r N E W L I N E | I D ‘ = ’ e x p r N E W L I N E | N E W L I N E ; e x p r : e x p r ( ‘ * ’ | ’ / ’ ) e x p r | e x p r ( ‘ + ’ | ’ - ’ ) e x p r | I N T | I D | ‘ ( ‘ e x p r ‘ ) ’ ; - Full example: Computer Science / Software Engineering Notes Network g r a m m a r E x p r ; p r o g : s t a t + ; s t a t : e x p r N E W L I N E | I D ‘ = ’ e x p r N E W L I N E | N E W L I N E ; e x p r : e x p r ( ‘ * ’ | ’ / ’ ) e x p r | e x p r ( ‘ + ’ | ’ - ’ ) e x p r | I N T | I D | ‘ ( ‘ e x p r ‘ ) ’ ; I D : [ a - z A - Z ] + ; I N T : [ 0 - 9 ] + ; N E W L I N E : ‘ \\ r ’ ? ‘ \\ n ’ ; W S : [ \\ t ] + - > s k i p ; / / ‘ - > s k i p ’ i s u s e d t o i g n o r e w h i t e s p a c e - ANTLR generates recursive-descent parsers (if you remember from PLC, those are LL parsers, and work like context-free grammars). - You can define grammar rules like this: Grammar rule Matches assign : ID '=' expr ';' ; foo = 1; bar = 2; - We’ve created an assignment rule. - Now our parser can recognise when we’re trying to assign a value to something. - The method that ANTLR generates for this rule looks like this: The actual co de void assign () { match(ID);match( '=' ); expr();match( ';' ); } - That’s just an assignment though. - What a boring language it’d be if all it could do was assign values! - We could create a more general ‘statement’rule: Grammar rule Matches stat: assign | ifstat | whilestat ... foo = 1; bar = 2; if (true) { ... } while (1 == 1) { ... } Computer Science / Software Engineering Notes Network ; - These different paths:assignment, if statement, and while loop, are called altern atives. - The method that ANTLR generates for our statement rule looks like this: The actual co de void stat() { switch ( <<current input token>> ) { case ID: assign(); break ; case IF: ifstat(); break ; case WHILE: whilestat(); break ; ...default : <<raise no viable alternative exception>> } } - Notice how ANTLR has to use lookahead tokens to determine if we’re doing an assignment, an if statement, or a while loop. - By ‘lookahead token’, I mean the parser has to see if the next token is an id, ‘if’, or ‘while’. - ANTLR handles all of this logic for you, so don’t worry too much;just keep it in mind. Example Windows 98 maze screensaver - Let’s say there’s a maze, with one entrance and one exit. - There are words all across the floor. Every sequence of words along a path from the entrance to the exit represents a valid sentence in our language. - Given a sentence, if you can make a path from the entrance to the exit using the words in the sentence, you have a valid sentence in the language. - If you hit a fork in the road, which path do you choose? - You look at each path and see which words correlate to the next words in your sentence. - Basically, you lookahead! - What if there are multiple ways to reach the exit with the same sentence? - Then the sentence is ambiguous in its semantics. - Wanna hear an ambiguous sentence? “You Can’t Put Too Much Water into a Nuclear Reactor” - Does that mean Computer Science / Software Engineering Notes Network - you’re not allowed to put too much water in, because if you do, something bad will happen - Or does it mean - it is impossible to put too much water in, so put in as much as you like - Here’s another: “To my Ph.D supervisor, for whom no thanks is too much” - Does that mean - the supervisor is so good, no amount of thanks would be too much - Or does it mean - the supervisor is so bad, even not thanking them is giving them too much credit - Here’s another, but it’s an ambiguous grammar: Grammar rule Matches stat: expr ';' | ID '(' ')' ';' ; expr: ID '(' ')' | INT ; f();foo();bar(); - This grammar recognises function calls, but it can do it in two ways: f ( ) ; as expr f ( ) ; as stat - When this happens, ANTLR picks the first rule specified in the grammar. - So f ( ) ; would be represented as an e x p r . - This happens in lexing too: Grammar rule Matches BEGIN: ‘begin’ ; ID: [a-z]+ ; begin - The word ‘begin’can be classed as either BEGIN or ID. - ANTLR picks the first rule specified, so ‘begin’will be classed as BEGIN. Computer Science / Software Engineering Notes Network Listeners - So, we can define languages and generate ASTs from source code. - But this is Automated Code Generation! Where’s the generated code? - In ANTLR, we can do more with our ASTs than just create them. - We can traverse them, and run some code based on what we run into. - There’s two ways to traverse our ASTs: - Listeners - Visitors - They both achieve the same thing, but one approach may be more convenient for certain tasks than the other. - Listen ers use an event-driven model. - ANTLR has a ‘tree walker’that traverses across the parse tree, and fires off certain events when it reaches certain nodes. - There are two events per parse rule R: - e n t e r R - e x i t R - As you can probably guess, they are fired off when the parse tree enters a node with parse rule R and when the parse tree leaves a node with parse rule R. - Let’s look at an example: - On the left, we have a parse tree of s p = 1 0 0 ; - On the right, we have that same tree, but with each node’s class name. - If “Foo” is the name of the grammar, and if we wanted to run some code when the tree walker reached our expression “100”, we can override the “e n t e r E x p r ” method in our F o o B a s e L i s t e n e r . - How does the tree walker actually traverse through the tree? - It uses depth-first search: Computer Science / Software Engineering Notes Network - Here’s all the event callbacks that would be run, from start to finish: e n t e r S t a t ( S t a t C o n t e x t ) e n t e r A s s i g n ( A s s i g n C o n t e x t ) v i s i t T e r m i n a l ( T e r m i n a l N o d e ) Computer Science / Software Engineering Notes Network v i s i t T e r m i n a l ( T e r m i n a l N o d e ) e n t e r E x p r ( E x p r C o n t e x t ) v i s i t T e r m i n a l ( T e r m i n a l N o d e ) e x i t E x p r ( E x p r C o n t e x t ) v i s i t T e r m i n a l ( T e r m i n a l N o d e ) e x i t A s s i g n ( A s s i g n C o n t e x t ) Computer Science / Software Engineering Notes Network e x i t S t a t ( S t a t C o n t e x t ) Software Sec Example - Let’s have a proper example! - There’s no coursework for this, so I’ll guide you how to compile all this yourself. - Call it a Notes Network lab! - Let’s say you’re doing Software Security, and you want to convert lists of numbers into hex value strings so you can pipe them into insecure C programs. - So, we have: - { 1 , 6 , 7 , 8 3 , 1 2 } - ... and we want to convert it to: - “ \\ u 0 0 0 1 \\ u 0 0 0 6 \\ u 0 0 0 7 \\ u 0 0 5 3 \\ u 0 0 0 C ” - I know;we could just write a method for this, but let’s go along with this. - Let’s define a grammar for this, and save it as A r r a y I n i t . g 4 : A r r a y I n i t . g 4 g r a m m a r A r r a y I n i t ; / / A r u l e c a l l e d l i s t t h a t m a t c h e s c o m m a - s e p a r a t e d v a l u e s b e t w e e n { . . . } . l i s t : ' { ' v a l u e ( ' , ' v a l u e ) * ' } ' ; / / m u s t m a t c h a t l e a s t o n e v a l u e / / A v a l u e c a n b e e i t h e r a n e s t e d a r r a y / s t r u c t o r a s i m p l e i n t e g e r ( I N T ) v a l u e : l i s t | I N T ; / / P a r s e r r u l e s s t a r t w i t h l o w e r c a s e l e t t e r s , l e x e r r u l e s w i t h u p p e r c a s e I N T : [ 0 - 9 ] + ; / / D e f i n e t o k e n I N T a s o n e o r m o r e d i g i t s W S : [ \\ t \\ r \\ n ] + - > s k i p ; / / D e f i n e w h i t e s p a c e r u l e , t o s s i t o u t - You really should have ANTLR installed. - Do you? Of course!I’m well-behaved and I follow the rules. No way! ANTLR sucks like everything else. Good job! I don’t have any rewards to give you,so,um... here’s a monad. Yare yare... you can’t follow along if you don’t have A NTLR. Go and follow the instructions on the official site to install it, as well as the commands. Computer Science / Software Engineering Notes Network ( > > = ) : : m a → ( a → m b ) → m b Or, if you really don’t care, feel free to read on. - I’m using the Linux commands, so if you’re on Windows, just substitute my commands for yours. - Let’s compile the grammar: $ a n t l r 4 A r r a y I n i t . g 4 - Let’s check if it works! - Compile the Java code to bytecode into an output folder: $ j a v a c A r r a y I n i t * . j a v a - d o u t - Now let’s parse a simple list and see its parse tree: $ c d o u t $ g r u n A r r a y I n i t l i s t - g u i { 1 , 2 , 3 } C T R L + D - (If you’re on Unix, remember, input a number list and press CTRL+D to show the tree. On Windows, it’s CTRL + Z.) - You should see something like this appear: - Wahoo! We have our language, and it parses lists correctly. - Now, how do we actually convert this list to hex values? - The general idea is this: - When we enter ‘list’, we’ll print opened double quotes “ - When we enter a value, we’ll convert it to hex and print it. - When we exit ‘list’, we’ll print closed double quotes ” - How do we do that? - Remember the ‘events’from earlier? - The three events we need are: - e n t e r L i s t - e n t e r V a l u e - e x i t L i s t - How do we attach code to those events? Computer Science / Software Engineering Notes Network - We do so by making a new class that extends A r r a y I n i t B a s e L i s t e n e r : S h o r t T o U n i c o d e S t r i n g . j a v a p u b l i c c l a s s S h o r t T o U n i c o d e S t r i n g e x t e n d s A r r a y I n i t B a s e L i s t e n e r { @ O v e r r i d e p u b l i c v o i d e n t e r L i s t ( A r r a y I n i t P a r s e r . L i s t C o n t e x t c t x ) { S y s t e m . o u t . p r i n t ( ' \" ' ) ; } @ O v e r r i d e p u b l i c v o i d e n t e r V a l u e ( A r r a y I n i t P a r s e r . V a l u e C o n t e x t c t x ) { i n t v a l u e = I n t e g e r . v a l u e O f ( c t x . I N T ( ) . g e t T e x t ( ) ) ; S y s t e m . o u t . p r i n t f ( \" \\ \\ u % 0 4 x \" , v a l u e ) ; } @ O v e r r i d e p u b l i c v o i d e x i t L i s t ( A r r a y I n i t P a r s e r . L i s t C o n t e x t c t x ) { S y s t e m . o u t . p r i n t l n ( ' \" ' ) ; } } - Cool! Now, when we e n t e r L i s t , we print an open quote. Each time we e n t e r V a l u e , we print the hex value of it. When we e x i t L i s t , we close the quotes. - You’ll notice that, in the Contexts, you can reference parts of the parsing rule by their name in the grammar. - For example, when we e n t e r V a l u e , we can reference the I N T token with c t x . I N T ( ) . - There are no checks for whether the v a l u e is one with l i s t or with I N T , because it doesn’t support nested lists yet. - Yes, very cool, but, um... how do we actually run it? - We need a Main class that: 1. Loads up some A r r a y I n i t source code 2. C omputes the parse tree 3. Walks through the parse tree with our new listener - Like this: M a i n . j a v a i m p o r t o r g . a n t l r . v 4 . r u n t i m e . * ; i m p o r t o r g . a n t l r . v 4 . r u n t i m e . t r e e . * ; i m p o r t s t a t i c o r g . a n t l r . v 4 . r u n t i m e . C h a r S t r e a m s . f r o m F i l e N a m e ; p u b l i c c l a s s M a i n { p u b l i c s t a t i c f i n a l S t r i n g F I L E N A M E = \" t e s t . t x t \" ; p u b l i c s t a t i c v o i d m a i n ( S t r i n g [ ] a r g s ) t h r o w s E x c e p t i o n { v a r i n p u t S t r e a m = g e t I n p u t S t r e a m ( ) ; Computer Science / Software Engineering Notes Network v a r p a r s e T r e e = g e t P a r s e T r e e ( i n p u t S t r e a m ) ; w a l k T h r o u g h P a r s e T r e e W i t h L i s t e n e r ( p a r s e T r e e , n e w S h o r t T o U n i c o d e S t r i n g ( ) ) ; } p u b l i c s t a t i c C h a r S t r e a m g e t I n p u t S t r e a m ( ) t h r o w s E x c e p t i o n { r e t u r n f r o m F i l e N a m e ( F I L E N A M E ) ; } p u b l i c s t a t i c P a r s e T r e e g e t P a r s e T r e e ( C h a r S t r e a m i n p u t S t r e a m ) { v a r l e x e r = n e w A r r a y I n i t L e x e r ( i n p u t S t r e a m ) ; v a r t o k e n s = n e w C o m m o n T o k e n S t r e a m ( l e x e r ) ; v a r p a r s e r = n e w A r r a y I n i t P a r s e r ( t o k e n s ) ; r e t u r n p a r s e r . l i s t ( ) ; } p u b l i c s t a t i c v o i d w a l k T h r o u g h P a r s e T r e e W i t h L i s t e n e r ( P a r s e T r e e p a r s e T r e e , P a r s e T r e e L i s t e n e r l i s t e n e r ) { v a r w a l k e r = n e w P a r s e T r e e W a l k e r ( ) ; w a l k e r . w a l k ( l i s t e n e r , p a r s e T r e e ) ; } } - Don’t forget to write some A r r a y I n i t source code into a text file for our program to read! o u t / t e s t . t x t { 1 , 6 , 7 , 8 3 , 1 2 } - Now, we can finally compile everything again and give it a spin: $ j a v a c * . j a v a - d o u t $ c d o u t $ j a v a M a i n \" \\ u 0 0 0 1 \\ u 0 0 0 6 \\ u 0 0 0 7 \\ u 0 0 5 3 \\ u 0 0 0 c \" - It’s like PLC all over again 😊 - Let’s take a step back and look at what we’re actually doing here. - We’re writing a whole new language just to convert integers to a hex string. - That’s like creating an English Two just to say hello. - Can we do something more complicated with this? - Yes! - Did you know that, with a grammar for Java, you can walk through Java code? - You can do things like: - Creating interfaces out of classes - Convert interfaces to abstract classes - Print information about a Java program - Change all programming patterns to monads Computer Science / Software Engineering Notes Network - There’s an example in the slides for making interfaces out of classes, but the main points are: - Use events like enterClassDeclaration, exitClassDeclaration, enterMethodDeclaration, exitMethodDeclaration. - Print i n t e r f a c e I { on entering a class, and a closing brace } on exiting a class. - On entering a method, get the type and parameters using the t o k e n s . g e t T e x t method on parts of the parse tree that point to the method type and parameters, respectively (this gets the input text that caused it to match that bit of the parse tree), then print them as a method declaration in the interface. - This isn’t just for Java:you can do this with a whole range of languages! - The possibilities truly are endless. Visitors - Let’s summarise what the Visitor pattern is, exactly (in terms of ANTLR): - There exists a Visitor interface containing the visit method, which performs some kind of logic on a part of the overall structure. - On each element of the structure, there exists an accept method, which runs the correct visit method for that type of element. Computer Science / Software Engineering Notes Network - Hmm... that diagram may have made it more confusing. - Let’s just talk about it for now 😅 - As an alternative to listeners, ANTLR provides visitors for the nodes in our parse tree. - The difference is this: - With listeners, you get both ‘enter’and ‘exit’methods for the traversal, but the traversal doesn’t return anything. - With visitors, you only get methods for ‘visiting’the nodes, but the traversal has a return value. - So, for tasks that don’t have an aggregated return value, listeners might be more helpful, like converting Java classes to interfaces and writing it to a separate file. - However, visitors would be more helpful for tasks with an aggregated value, like finding the sum of all numbers in a binary tree, where each node has a value. - What if we just had another Notes Network lab? Then I can explain things in order. B inary Tree Example - In this example, we’re going to make a binary tree language, where each parent has two children, and each node has a number, like so: - We’re going to make two visitors: - One that sums all the numbers in the tree - One that gets the maximum number in the tree - First, let’s make that language! B i n a r y T r e e . g 4 g r a m m a r B i n a r y T r e e ; b i n a r y t r e e : ' ( ' v a l u e s u b t r e e s u b t r e e ' ) ' ; s u b t r e e : v a l u e | b i n a r y t r e e ; v a l u e : I N T ; Computer Science / Software Engineering Notes Network I N T : [ 0 - 9 ] + ; / / D e f i n e t o k e n I N T a s o n e o r m o r e d i g i t s W S : [ \\ t \\ r \\ n ] + - > s k i p ; / / D e f i n e w h i t e s p a c e r u l e , t o s s i t o u t - With this, we can represent the tree above as: - ( 5 ( 6 7 ( 8 9 1 0 ) ) ( 1 1 1 2 1 3 ) ) Debugger’s note As I was writing this binary tree grammar, I kept running into syntax errors.It was really strange;I could’ve sworn my AN TLR syntax was perfect. Turns out, AN TLR doesn’t like the word ‘tree’as a parsing rule name. ¯\\_(ツ)_/¯ - Let’s give this a try! - Compile the language: $ a n t l r 4 A r r a y I n i t . g 4 - v i s i t o r - Don’t forget the - v i s i t o r flag, we’ll need it later. - Let’s try parsing our tree from above: $ j a v a c * . j a v a - d o u t $ c d o u t $ g r u n B i n a r y T r e e b i n a r y t r e e - g u i ( 5 ( 6 7 ( 8 9 1 0 ) ) ( 1 1 1 2 1 3 ) ) C T R L + D - Looks good to me! Computer Science / Software Engineering Notes Network - Now, let’s write our visitors. - Like listeners, we need to make a new class. - This time though, it needs to extend the base visitor class instead of the base listener class: B i n a r y T r e e S u m V i s i t o r . j a v a p u b l i c c l a s s B i n a r y T r e e S u m V i s i t o r e x t e n d s B i n a r y T r e e B a s e V i s i t o r < I n t e g e r > { @ O v e r r i d e p u b l i c I n t e g e r v i s i t B i n a r y t r e e ( B i n a r y T r e e P a r s e r . B i n a r y t r e e C o n t e x t c t x ) { i n t v a l = v i s i t ( c t x . v a l u e ( ) ) ; i n t l e f t V a l = v i s i t ( c t x . s u b t r e e ( 0 ) ) ; i n t r i g h t V a l = v i s i t ( c t x . s u b t r e e ( 1 ) ) ; r e t u r n v a l + l e f t V a l + r i g h t V a l ; } @ O v e r r i d e p u b l i c I n t e g e r v i s i t S u b t r e e ( B i n a r y T r e e P a r s e r . S u b t r e e C o n t e x t c t x ) { r e t u r n v i s i t C h i l d r e n ( c t x ) ; } @ O v e r r i d e p u b l i c I n t e g e r v i s i t V a l u e ( B i n a r y T r e e P a r s e r . V a l u e C o n t e x t c t x ) { i n t v a l = I n t e g e r . v a l u e O f ( c t x . I N T ( ) . g e t T e x t ( ) ) ; r e t u r n v a l ; } } - Unlike listeners, visitors are parameterised on the return type of the visitor function. - Our sum visitor is returning an integer:the sum, so we parametrize it on Integer. - We cover each case of visiting each node: - When we visit a binary tree, add up the value, the left subtree sum, and the right subtree sum, and return that. - When we visit a subtree, just return whatever the children return (it’s going to be a value or another binary tree anyway) - When we visit a value, get the integer of this node and return it. - Cool! Now let’s whip up a quick Main method, similar to the one in the listeners example, to test this: M a i n . j a v a i m p o r t o r g . a n t l r . v 4 . r u n t i m e . * ; i m p o r t o r g . a n t l r . v 4 . r u n t i m e . t r e e . * ; i m p o r t s t a t i c o r g . a n t l r . v 4 . r u n t i m e . C h a r S t r e a m s . f r o m F i l e N a m e ; p u b l i c c l a s s M a i n { p u b l i c s t a t i c f i n a l S t r i n g F I L E N A M E = \" t e s t . t x t \" ; p u b l i c s t a t i c v o i d m a i n ( S t r i n g [ ] a r g s ) t h r o w s E x c e p t i o n { v a r i n p u t S t r e a m = g e t I n p u t S t r e a m ( ) ; Computer Science / Software Engineering Notes Network v a r p a r s e T r e e = g e t P a r s e T r e e ( i n p u t S t r e a m ) ; v a r s u m = w a l k T h r o u g h P a r s e T r e e W i t h S u m V i s i t o r ( p a r s e T r e e ) ; S y s t e m . o u t . p r i n t l n ( \" S u m : \" + s u m ) ; } p u b l i c s t a t i c C h a r S t r e a m g e t I n p u t S t r e a m ( ) t h r o w s E x c e p t i o n { r e t u r n f r o m F i l e N a m e ( F I L E N A M E ) ; } p u b l i c s t a t i c P a r s e T r e e g e t P a r s e T r e e ( C h a r S t r e a m i n p u t S t r e a m ) { v a r l e x e r = n e w A r r a y I n i t L e x e r ( i n p u t S t r e a m ) ; v a r t o k e n s = n e w C o m m o n T o k e n S t r e a m ( l e x e r ) ; v a r p a r s e r = n e w A r r a y I n i t P a r s e r ( t o k e n s ) ; r e t u r n p a r s e r . b i n a r y t r e e ( ) ; } p u b l i c s t a t i c i n t w a l k T h r o u g h P a r s e T r e e W i t h S u m V i s i t o r ( P a r s e T r e e p a r s e T r e e ) { v a r v i s i t o r = n e w B i n a r y T r e e S u m V i s i t o r ( ) ; v a r s u m = v i s i t o r . v i s i t ( p a r s e T r e e ) ; r e t u r n s u m ; } } - Of course, don’t forget the binary tree source code! o u t / t e s t . t x t ( 5 ( 6 7 ( 8 9 1 0 ) ) ( 1 1 1 2 1 3 ) ) - Now, let’s give this a test: $ j a v a c * . j a v a - d o u t $ c d o u t $ j a v a M a i n S u m : 8 1 - Woohoo! It worked! - Now, let’s try that maximum number visitor: B i n a r y T r e e M a x V i s i t o r . j a v a p u b l i c c l a s s B i n a r y T r e e S u m V i s i t o r e x t e n d s B i n a r y T r e e B a s e V i s i t o r < I n t e g e r > { @ O v e r r i d e p u b l i c I n t e g e r v i s i t B i n a r y t r e e ( B i n a r y T r e e P a r s e r . B i n a r y t r e e C o n t e x t c t x ) { i n t v a l = v i s i t ( c t x . v a l u e ( ) ) ; i n t l e f t V a l = v i s i t ( c t x . s u b t r e e ( 0 ) ) ; i n t r i g h t V a l = v i s i t ( c t x . s u b t r e e ( 1 ) ) ; i f ( v a l > l e f t V a l & & v a l > r i g h t V a l ) r e t u r n v a l ; Computer Science / Software Engineering Notes Network i f ( l e f t V a l > r i g h t V a l ) r e t u r n l e f t V a l ; r e t u r n r i g h t V a l ; }@ O v e r r i d e p u b l i c I n t e g e r v i s i t S u b t r e e ( B i n a r y T r e e P a r s e r . S u b t r e e C o n t e x t c t x ) { r e t u r n v i s i t C h i l d r e n ( c t x ) ; } @ O v e r r i d e p u b l i c I n t e g e r v i s i t V a l u e ( B i n a r y T r e e P a r s e r . V a l u e C o n t e x t c t x ) { i n t v a l = I n t e g e r . v a l u e O f ( c t x . I N T ( ) . g e t T e x t ( ) ) ; r e t u r n v a l ; } } - It’s virtually the same, except for the v i s i t B i n a r y T r e e method, which returns the biggest number instead of summing them all. - Let’s tweak the main method to use this visitor now: M a i n . j a v a . . . p u b l i c c l a s s M a i n { p u b l i c s t a t i c f i n a l S t r i n g F I L E N A M E = \" t e s t . t x t \" ; p u b l i c s t a t i c v o i d m a i n ( S t r i n g [ ] a r g s ) t h r o w s E x c e p t i o n { . . . v a r m a x = w a l k T h r o u g h P a r s e T r e e W i t h M a x V i s i t o r ( p a r s e T r e e ) ; S y s t e m . o u t . p r i n t l n ( \" M a x : \" + m a x ) ; } p u b l i c s t a t i c i n t w a l k T h r o u g h P a r s e T r e e W i t h M a x V i s i t o r ( P a r s e T r e e p a r s e T r e e ) { v a r v i s i t o r = n e w B i n a r y T r e e M a x V i s i t o r ( ) ; v a r m a x = v i s i t o r . v i s i t ( p a r s e T r e e ) ; r e t u r n m a x ; } } - Let’s compile, run Main, and see if we really get the biggest node value: $ j a v a c * . j a v a - d o u t $ c d o u t $ j a v a M a i n S u m : 8 1 M a x : 1 3 - Would you look at that? It found the biggest node in the tree! Computer Science / Software Engineering Notes Network Other Features A lternative Labels - You can label parsing rules to control the names of the listener and visitor methods: e x p r : e x p r ( ‘ * ’ | ’ / ’ ) e x p r # M u l D i v | e x p r ( ‘ + ’ | ’ - ’ ) e x p r # A d d S u b | I N T # i n t | I D # i d | ‘ ( ‘ e x p r ‘ ) ’ # p a r e n s ; - They look like comments, but they’re not! - When you name rules like these, you can get methods like: - v i s i t M u l D i v - v i s i t A d d S u b - v i s i t I n t - v i s i t I d - v i s i t P a r e n s Rule Element Labels - In a parsing rule, you can name a token to reference later: e x p r : v a l u e o p = ( ‘ + ’ | ’ - ’ | ‘ * ’ | ’ / ’ ) v a l u e ; A D D : ‘ + ’ ; S U B : ’ - ’ ; M U L : ‘ * ’ ; D I V : ’ / ’ ; - Then, when you have a Context object for this rule through a listener or visitor method, you can refer to the token using the name you’ve given it: p u b l i c I n t e g e r v i s i t E x p r ( M y G r a m m a r P a r s e r . E x p r C o n t e x t c t x ) { s w i t c h ( c t x . o p . g e t T y p e ( ) ) { c a s e M y G r a m m a r P a r s e r . A D D : S y s t e m . o u t . p r i n t l n ( \" T h i s i s a n a d d i t i o n e x p r e s s i o n \" ) ; b r e a k ; c a s e M y G r a m m a r P a r s e r . S U B : S y s t e m . o u t . p r i n t l n ( \" T h i s i s a s u b t r a c t i o n e x p r e s s i o n \" ) ; b r e a k ; c a s e M y G r a m m a r P a r s e r . M U L : S y s t e m . o u t . p r i n t l n ( \" T h i s i s a m u l t i p l i c a t i o n e x p r e s s i o n \" ) ; b r e a k ; c a s e M y G r a m m a r P a r s e r . D I V : S y s t e m . o u t . p r i n t l n ( \" T h i s i s a d i v i s i o n e x p r e s s i o n \" ) ; b r e a k ; Computer Science / Software Engineering Notes Network } } A ctions - A ctio n s are blocks of code, encapsulated by { } , that you can run in your parsing rules. - Like so: e x p r : I N T ‘ + ’ I N T { S y s t e m . o u t . p r i n t l n ( “ Y o u ’ v e j u s t a d d e d ” ) ; } ; - You can also have seman tic p redicates, which are actions that return true or false, and if they return false, the parsing rule is skipped. - They are encapsulated with { } ? - Here’s an example that only adds two numbers if they’re both non-negative: e x p r : a = I N T ‘ + ’ b = I N T { I n t e g e r . p a r s e I n t ( $ a . t e x t ) > = 0 & & I n t e g e r . p a r s e I n t ( $ b . t e x t ) > = 0 ; } ? ; Node Values (A ttributes) - When you’re in an action, you can reference parts of the parse rule. - These are called attributes, and they must be prefixed with a $. - We’ve already done this above, but you can reference the tokens as to ken attributes: e x p r : I N T { S y s t e m . o u t . p r i n t l n ( “ i n t v a l u e : “ + $ I N T . t e x t ) ; } ; - ANTLR also allows parse tree nodes to store values. - You can think of this like a node ‘state’. - Return attributes are among such so-called rule attributes. - They can be changed using actions. - Here’s an example of an adding parse rule that stores the result in itself: e x p r r e t u r n s [ i n t v a l u e ] : a = I N T ' + ' b = I N T { $ v a l u e = I n t e g e r . p a r s e I n t ( $ a . t e x t ) + I n t e g e r . p a r s e I n t ( $ b . t e x t ) ; } ; - Now, we can access the ‘value’property of expr nodes: p u b l i c I n t e g e r v i s i t E x p r ( M y G r a m m a r P a r s e r . E x p r C o n t e x t c t x ) { c t x . v a l u e ; / / T h i s w i l l e q u a l t h e m a t c h e d ‘ a ’ + t h e m a t c h e d ‘ b ’ } - You can only store one value, though. - Another solution is mapping nodes to values, which you can do with the P a r s e T r e e P r o p e r t y < T > class. Computer Science / Software Engineering Notes Network TokenStreamRewriter - When we use a lexer, we get a token stream. - A token stream is just like normal streams in Java, but the elements are the tokens making up the input source code. - Did you know that it’s possible to ‘modify’a token stream using a T o k e n S t r e a m R e w r i t e r ? - Here’s a quick example of one, with a simple language of just two words:‘bold’and ‘deleteme’. - The T o k e n S t r e a m R e w r i t e r here puts asterisks around ‘bold’tokens and removes all ‘deleteme’tokens: T S R . g 4 g r a m m a r T S R ; p r o g r a m : p r o g r a m m E O F ; p r o g r a m m : b o l d | d e l e t e m e | b o l d p r o g r a m m | d e l e t e m e p r o g r a m m ; b o l d : B O L D ; d e l e t e m e : D E L E T E M E ; B O L D : ‘ b o l d ’ ; D E L E T E M E : ‘ d e l e t e m e ’ ; W S : [ \\ t \\ r \\ n ] + - > s k i p ; T S R M y L i s t e n e r . j a v a i m p o r t o r g . a n t l r . v 4 . r u n t i m e . * ; p u b l i c c l a s s T S R M y L i s t e n e r e x t e n d s T S R B a s e L i s t e n e r { p u b l i c T o k e n S t r e a m R e w r i t e r r e w r i t e r ; p u b l i c T S R M y L i s t e n e r ( T o k e n S t r e a m t o k e n s ) { r e w r i t e r = n e w T o k e n S t r e a m R e w r i t e r ( t o k e n s ) ; } @ O v e r r i d e p u b l i c v o i d e n t e r B o l d ( T S R P a r s e r . B o l d C o n t e x t c t x ) { r e w r i t e r . i n s e r t B e f o r e ( c t x . B O L D ( ) . g e t S y m b o l ( ) , ' * ' ) ; r e w r i t e r . i n s e r t A f t e r ( c t x . B O L D ( ) . g e t S y m b o l ( ) , ' * ' ) ; } @ O v e r r i d e p u b l i c v o i d e n t e r D e l e t e m e ( T S R P a r s e r . D e l e t e m e C o n t e x t c t x ) { Computer Science / Software Engineering Notes Network r e w r i t e r . d e l e t e ( c t x . D E L E T E M E ( ) . g e t S y m b o l ( ) ) ; } } M a i n . j a v a i m p o r t o r g . a n t l r . v 4 . r u n t i m e . * ; i m p o r t o r g . a n t l r . v 4 . r u n t i m e . t r e e . * ; i m p o r t s t a t i c o r g . a n t l r . v 4 . r u n t i m e . C h a r S t r e a m s . f r o m F i l e N a m e ; p u b l i c c l a s s M a i n { p u b l i c s t a t i c f i n a l S t r i n g F I L E N A M E = \" t e s t . t x t \" ; p u b l i c s t a t i c v o i d m a i n ( S t r i n g [ ] a r g s ) t h r o w s E x c e p t i o n { v a r i n p u t S t r e a m = f r o m F i l e N a m e ( F I L E N A M E ) ; v a r l e x e r = n e w T S R L e x e r ( i n p u t S t r e a m ) ; v a r t o k e n s = n e w C o m m o n T o k e n S t r e a m ( l e x e r ) ; v a r p a r s e r = n e w T S R P a r s e r ( t o k e n s ) ; v a r p a r s e T r e e = p a r s e r . p r o g r a m ( ) ; v a r w a l k e r = n e w P a r s e T r e e W a l k e r ( ) ; v a r l i s t e n e r = n e w T S R M y L i s t e n e r ( t o k e n s ) ; w a l k e r . w a l k ( l i s t e n e r , p a r s e T r e e ) ; / / R e a d s n e w t o k e n s t r e a m S y s t e m . o u t . p r i n t l n ( l i s t e n e r . r e w r i t e r . g e t T e x t ( ) ) ; } } o u t / t e s t . t x t b o l d d e l e t e m e b o l d d e l e t e m e b o l d - Now, let’s give this a test: $ j a v a c * . j a v a - d o u t $ c d o u t $ j a v a M a i n * b o l d * * b o l d * * b o l d * - It works! - Keep in mind that to make a TokenStreamRewriter, you need to feed it the original TokenStream. - However, TokenStreamRewriters do not mutate the original TokenStream at all (hence why I used ‘’around the word ‘modify’earlier). Computer Science / Software Engineering Notes Network - Instead, T o k e n S t r e a m R e w r i t e r s store buffered changes, and they’re only computed when you run the g e t T e x t method on the T o k e n S t r e a m R e w r i t e r . - They’re useful for when your program is doing slight modifications to some kind of input, like adding a ‘i m p l e m e n t s I ’bit to your classes as you’re generating interfaces. Why ANTLR Sucks - Alas... according to Automated Code Generation, everything sucks. - ANTLR is no exception. - It’s really good for expressing grammars, generating parsers, and walking through parse trees. - However, it’s not great for transforming parse trees to ASTs. - To generate code using listeners and visitors, you’re essentially: - Writing strings - Rewriting token streams - Manually building AST nodes of the generator target - So if ANTLR is crap at code generation, why are we learning it? - The key thing to take away here is: - generalised input and - traversal over model structures. - It’s not really a transformation tool, but it meets the above points well for textual domain models. - If you wanna find out more about transformation tools for textual domain models, check out Stratego. - There’s plenty of graphical ones too: - Acceleo - JET - Epsilon - ATL - Xpand","libVersion":"0.3.2","langs":""}